%%% Copyright (c) Meta Platforms, Inc. and……         |
%%%                                        |         |
%%% This source code is licensed under the……         |
%%% the LICENSE file in the root directory……         |
                                           |         |
-module(records).                          |         |
                                           |         |
-compile([export_all, nowarn_export_all]). |         |
                                           |         |
-record(rec1, {}).                         |         |
-record(rec2, {}).                         |         |
-record(rec3, {}).                         |         |
                                           |         |
-record(any_foo, {id, name}).              |         |
                                           |         |
-record(foo, {                             |         |
    id :: integer(),                       |         |
    name :: atom()                         |         |
}).                                        |         |
                                           |         |
-record(foo_def, {                         |         |
    id = 1 :: integer(),                   |         |
    name = default :: atom()               |         |
}).                                        |         |
                                           |         |
-spec mk_rec1_pos() -> #rec1{}.            |         |
mk_rec1_pos() -> #rec1{}.                  | OK      |
                                           |         |
-spec mk_rec1_neg() -> #rec1{}.            |         |
mk_rec1_neg() -> #rec2{}.                  | ERROR   | #rec2{...}.
                                           |         | Expression has type:   #rec2{}
                                           |         | Context expected type: #rec1{}
                                           |         |
-spec mk_rec1a_pos() -> #rec1{}.           |         |
mk_rec1a_pos() ->                          | OK      |
    R = #rec1{},                           |         |
    R.                                     |         |
                                           |         |
-spec mk_rec1a_neg() -> #rec1{}.           |         |
mk_rec1a_neg() ->                          | ERROR   |
    R = #rec2{},                           |         |
    R.                                     |         | R.
                                           |         | Expression has type:   #rec2{}
                                           |         | Context expected type: #rec1{}
                                           |         |
-spec mk_rec_pos(atom()) ->                |         |
    #rec1{} | #rec2{}.                     |         |
mk_rec_pos(rec1) -> #rec1{};               | OK      |
mk_rec_pos(rec2) -> #rec2{}.               |         |
                                           |         |
-spec mk_rec_neg(atom()) ->                |         |
    #rec1{} | #rec3{}.                     |         |
mk_rec_neg(rec1) -> #rec1{};               | ERROR   |
mk_rec_neg(rec2) -> #rec2{}.               |         | #rec2{...}.
                                           |         | Expression has type:   #rec2{}
                                           |         | Context expected type: #rec1{} | #rec3{}
                                           |         | 
                                           |         |   #rec2{} is not compatible with #rec1{} | #rec3{}
                                           |         |   because
                                           |         |   #rec2{} is not compatible with #rec1{}
                                           |         |
-spec mk_foo_pos() -> #foo{}.              |         |
mk_foo_pos() ->                            | OK      |
    Foo = #foo{id = 42},                   |         |
    Foo.                                   |         |
                                           |         |
-spec mk_foo_neg() -> #foo{}.              |         |
mk_foo_neg() ->                            | ERROR   |
    Foo = #foo{name = bar},                |         | #foo{...}: id is 'undefined'

    Foo.                                   |         |
                                           |         |
-spec fix_foo_pos(#foo{}) -> #foo{}.       |         |
fix_foo_pos(Foo) ->                        | OK      |
    Foo#foo{name = default, id = 0}.       |         |
                                           |         |
-spec fix_foo1_pos(#foo{}) -> #foo{}.      |         |
fix_foo1_pos(Foo) ->                       | OK      |
    Foo1 = Foo#foo{name = default, id = 0}……         |
    Foo1.                                  |         |
                                           |         |
-spec fix_foo_neg(#foo{}) -> #foo{}.       |         |
fix_foo_neg(Foo) ->                        | ERROR   |
    Foo#foo_def{name = default, id = 0}.   |         | ...#foo_def{...}.
                                           |         | Expression has type:   #foo_def{}
                                           |         | Context expected type: #foo{}
                                           |         |
-spec index1_pos() -> integer().           |         |
index1_pos() ->                            | OK      |
    #foo.name.                             |         |
                                           |         |
-spec index2_pos() -> integer().           |         |
index2_pos() ->                            | OK      |
    Index = #foo.name,                     |         |
    Index.                                 |         |
                                           |         |
-spec index1_neg() -> atom().              |         |
index1_neg() ->                            | ERROR   |
    #foo.name.                             |         | #foo.name.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec index2_neg() -> atom().              |         |
index2_neg() ->                            | ERROR   |
    Index = #foo.name,                     |         |
    Index.                                 |         | Index.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec select1_pos(#foo{}) -> integer().    |         |
select1_pos(Foo) ->                        | OK      |
    Foo#foo.id.                            |         |
                                           |         |
-spec select2_pos(#foo{}) -> integer().    |         |
select2_pos(Foo) ->                        | OK      |
    Id = Foo#foo.id,                       |         |
    Id.                                    |         |
                                           |         |
-spec select1_neg(#foo{}) -> integer().    |         |
select1_neg(Foo) ->                        | ERROR   |
    Foo#foo.name.                          |         | ...#foo.name.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
                                           |         |
-spec select2_neg(#foo{}) -> integer().    |         |
select2_neg(Foo) ->                        | ERROR   |
    Id = Foo#foo.name,                     |         |
    Id.                                    |         | Id.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
                                           |         |
-spec rec_index_pat_pos(term())            |         |
    -> integer().                          |         |
rec_index_pat_pos(#foo.id = I) -> I.       | OK      |
                                           |         |
-spec rec_index_pat_neg(term())            |         |
        -> atom().                         |         |
rec_index_pat_neg(#foo.id = I) -> I.       | ERROR   | I.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec rec_pat_pos(term())                  |         |
        -> {integer(), atom()}.            |         |
rec_pat_pos(#foo{id = I, name = N}) ->     | OK      |
    {I, N}.                                |         |
                                           |         |
-spec rec_pat_neg(term())                  |         |
        -> {integer(), atom()}.            |         |
rec_pat_neg(#foo{id = I, name = N}) ->     | ERROR   |
    {N, I}.                                |         | {N, I}.
                                           |         | Expression has type:   {atom(), number()}
                                           |         | Context expected type: {number(), atom()}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {atom(), number()} is not compatible with {number(), atom()}
                                           |         |   because
                                           |         |   atom() is not compatible with number()
                                           |         |
-spec pat_fields(#any_foo{}) ->            |         |
    {#foo{}, #foo{}}.                      |         |
pat_fields(                                | OK      |
    #any_foo{                              |         |
        id = (#foo{} = I),                 |         |
        name = (#foo{} = N)                |         |
    }                                      |         |
) -> {I, N}.                               |         |
                                           |         |
-spec rec_guard1(term()) -> #foo{}.        |         |
rec_guard1(Foo)                            | OK      |
    when Foo#foo.id > 0 -> Foo.            |         |
                                           |         |
-spec rec_guard2_neg(term()) -> ok.        |         |
rec_guard2_neg(Foo)                        | ERROR   |
    when Foo == #foo{} -> ok.              |         | #foo{...}: id is 'undefined'

                                           |         |
-spec rec_guard3_pos(term(), term())       |         |
    -> number().                           |         |
rec_guard3_pos(Foo, X)                     | OK      |
    when Foo == #foo_def{id = X} -> X.     |         |
                                           |         |
-spec rec_guard4_neg(term(), term())       |         |
        -> atom().                         |         |
rec_guard4_neg(Foo, X)                     | ERROR   |
    when Foo == #foo_def{id = X} -> X.     |         | X.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-record(rec_a, { field :: number() }).     |         |
-record(rec_b, { field :: #rec_a{} }).     |         |
                                           |         |
-spec record_in_record                     |         |
    (#rec_b{}) -> number().                |         |
record_in_record(X) ->                     | OK      |
    (X#rec_b.field)#rec_a.field.           |         |
                                           |         |
-spec record_in_record_neg                 |         |
    (#rec_b{}) -> atom().                  |         |
record_in_record_neg(X) ->                 | ERROR   |
    (X#rec_b.field)#rec_a.field.           |         | ...#rec_a.field.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
% iodata() type is WIP                     |         |
-record(iodata_box, {iod :: iodata()}).    |         |
                                           |         |
-spec use_iodata_box() -> term().          |         |
use_iodata_box() ->                        | ERROR   |
    #iodata_box{iod = 's'}.                |         | 's'.
                                           |         | Expression has type:   's'
                                           |         | Context expected type: iodata()
                                           |         |
-record(mrec, {                            |         |
    id1 :: integer(),                      |         |
    id2 :: integer(),                      |         |
    name1 :: atom(),                       |         |
    name2 :: atom()                        |         |
}).                                        |         |
                                           |         |
-spec field_gen_mk() -> #mrec{}.           |         |
field_gen_mk() ->                          | OK      |
    #mrec{id1 = 1, id2 = 2, _ = ok}.       |         |
                                           |         |
-spec field_gen_mk_neg() -> #mrec{}.       |         |
field_gen_mk_neg() ->                      | ERROR   |
    #mrec{id1 = 1, name1 = n, _ = ok}.     |         | 'ok'.
                                           |         | Expression has type:   'ok'
                                           |         | Context expected type: number()
                                           |         |
-spec field_gen_pat(term())                |         |
        -> atom().                         |         |
field_gen_pat(                             | OK      |
    #mrec{id1 = 1, id2 = 2, _ = A}         |         |
) ->                                       |         |
    A.                                     |         |
                                           |         |
-spec field_gen_pat_neg(term())            |         |
        -> none().                         |         |
field_gen_pat_neg(                         | OK      |
    #mrec{id1 = 1, name1 = n, _ = A}       |         |
) ->                                       |         |
    % is both id2 (integer)                |         |
    % and name2 (atom)                     |         |
    A.                                     |         |
                                           |         |
-record(any_box, {                         |         |
    inner :: eqwalizer:refinable(term())   |         |
}).                                        |         |
                                           |         |
%% "Refined" record type                   |         |
-type int_box() ::                         |         |
    #any_box{inner :: integer()}.          |         |
                                           |         |
-spec mk_int_box_1_neg() -> int_box().     |         |
mk_int_box_1_neg() ->                      | ERROR   |
    #any_box{inner = ok}.                  |         | #any_box{...}.
                                           |         | Expression has type:   #any_box{inner :: 'ok'}
                                           |         | Context expected type: int_box()
                                           |         | 
                                           |         |   #any_box{inner :: 'ok'} is not compatible with int_box()
                                           |         |   because
                                           |         |   #any_box{inner :: 'ok'} is not compatible with #any_box{inner :: number()}
                                           |         |   because
                                           |         |   'ok' is not compatible with number()
                                           |         |
-spec mk_int_box_2_neg() -> IB when        |         |
    IB :: #any_box{inner :: integer()}.    |         |
mk_int_box_2_neg() ->                      | ERROR   |
    #any_box{inner = ok}.                  |         | #any_box{...}.
                                           |         | Expression has type:   #any_box{inner :: 'ok'}
                                           |         | Context expected type: #any_box{inner :: number()}
                                           |         | 
                                           |         |   #any_box{inner :: 'ok'} is not compatible with #any_box{inner :: number()}
                                           |         |   because
                                           |         |   'ok' is not compatible with number()
                                           |         |
-type box2(T) :: #any_box{inner :: T}.     |         |
                                           |         |
-spec unbox2(box2(T)) -> T.                |         |
unbox2(B) ->                               | OK      |
    B#any_box.inner.                       |         |
                                           |         |
-spec test_unbox2() -> ok.                 |         |
test_unbox2() ->                           | OK      |
    unbox2(#any_box{inner = ok}).          |         |
                                           |         |
-spec test_unbox2_gen() -> ok.             |         |
test_unbox2_gen() ->                       | OK      |
    unbox2(#any_box{_ = ok}).              |         |
                                           |         |
-spec test_unbox2_undef() -> undefined.    |         |
test_unbox2_undef() ->                     | OK      |
    unbox2(#any_box{}).                    |         |
                                           |         |
-type box2_tuple(T) ::                     |         |
    #any_box{inner :: T}.                  |         |
                                           |         |
-spec unbox2_tuple({any_box, T}) -> T.     |         |
unbox2_tuple({_, I}) -> I.                 | OK      |
                                           |         |
-spec test_unbox2_tuple() -> ok.           |         |
test_unbox2_tuple() ->                     | OK      |
    unbox2_tuple(#any_box{inner = ok}).    |         |
                                           |         |
-spec test_tuple_unbox2() -> ok.           |         |
test_tuple_unbox2() ->                     | OK      |
    unbox2({any_box, ok}).                 |         |
                                           |         |
-record(int_bool_box, {                    |         |
    inner = true :: eqwalizer:refinable(   |         |
        integer() | boolean()              |         |
    )                                      |         |
}).                                        |         |
                                           |         |
-type only_int_box() ::                    |         |
    #int_bool_box{inner :: integer()}.     |         |
                                           |         |
-type only_bool_box() ::                   |         |
    #int_bool_box{inner :: boolean()}.     |         |
                                           |         |
-type only_true_box() ::                   |         |
    #int_bool_box{inner :: true}.          |         |
                                           |         |
-type only_atom_box() ::                   |         |
    #int_bool_box{inner :: atom()}.        |         |
                                           |         |
-spec test_int_bool_box()                  |         |
    -> only_int_box().                     |         |
test_int_bool_box() ->                     | OK      |
    #int_bool_box{inner = 0}.              |         |
                                           |         |
-spec test_int_bool_box_neg()              |         |
    -> only_atom_box().                    |         |
test_int_bool_box_neg() ->                 | ERROR   |
    #int_bool_box{inner = a}.              |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number() | boolean()
                                           |         | 
                                           |         |   'a' is not compatible with number() | boolean()
                                           |         |   because
                                           |         |   'a' is not compatible with number()
                                           |         |
-spec test_int_bool_box_gen_neg()          |         |
    -> only_atom_box().                    |         |
test_int_bool_box_gen_neg() ->             | ERROR   |
    #int_bool_box{_ = a}.                  |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number() | boolean()
                                           |         | 
                                           |         |   'a' is not compatible with number() | boolean()
                                           |         |   because
                                           |         |   'a' is not compatible with number()
                                           |         |
-spec test_int_bool_box_default_neg()      |         |
    -> only_int_box().                     |         |
test_int_bool_box_default_neg() ->         | ERROR   |
    #int_bool_box{}.                       |         | #int_bool_box{...}.
                                           |         | Expression has type:   #int_bool_box{inner :: 'true'}
                                           |         | Context expected type: only_int_box()
                                           |         | 
                                           |         |   #int_bool_box{inner :: 'true'} is not compatible with only_int_box()
                                           |         |   because
                                           |         |   #int_bool_box{inner :: 'true'} is not compatible with #int_bool_box{inner :: number()}
                                           |         |   because
                                           |         |   'true' is not compatible with number()
                                           |         |
-spec test_int_bool_box_default()          |         |
    -> only_bool_box().                    |         |
test_int_bool_box_default() ->             | OK      |
    #int_bool_box{}.                       |         |
                                           |         |
-spec test_rec_update(only_bool_box())     |         |
    -> only_int_box().                     |         |
test_rec_update(B) ->                      | OK      |
    B#int_bool_box{inner = 3}.             |         |
                                           |         |
-spec test_rec_update_neg                  |         |
    (only_bool_box())                      |         |
    -> only_atom_box().                    |         |
test_rec_update_neg(B) ->                  | ERROR   |
    B#int_bool_box{inner = a}.             |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number() | boolean()
                                           |         | 
                                           |         |   'a' is not compatible with number() | boolean()
                                           |         |   because
                                           |         |   'a' is not compatible with number()
                                           |         |
-spec test_rec_update_02_neg               |         |
    (only_bool_box())                      |         |
    -> only_bool_box().                    |         |
test_rec_update_02_neg(B) ->               | ERROR   |
    B#int_bool_box{inner = 4}.             |         | ...#int_bool_box{...}.
                                           |         | Expression has type:   #int_bool_box{inner :: number()}
                                           |         | Context expected type: only_bool_box()
                                           |         | 
                                           |         |   #int_bool_box{inner :: number()} is not compatible with only_bool_box()
                                           |         |   because
                                           |         |   #int_bool_box{inner :: number()} is not compatible with #int_bool_box{inner :: boolean()}
                                           |         |   because
                                           |         |   number() is not compatible with boolean()
                                           |         |
-spec select_bad_neg(only_int_box())       |         |
    -> integer().                          |         |
select_bad_neg(R) ->                       | ERROR   |
    R#any_box.inner.                       |         | R.
                                           |         | Expression has type:   only_int_box()
                                           |         | Context expected type: #any_box{}
                                           |         | 
                                           |         |   only_int_box() is not compatible with #any_box{}
                                           |         |   because
                                           |         |   #int_bool_box{inner :: number()} is not compatible with #any_box{}
                                           |         |
-spec test_select_neg(only_int_box())      |         |
    -> boolean().                          |         |
test_select_neg(R) ->                      | ERROR   |
    R#int_bool_box.inner.                  |         | ...#int_bool_box.inner.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: boolean()
                                           |         |
-spec test_tuple_record_neg()              |         |
    -> #int_bool_box{}.                    |         |
test_tuple_record_neg() ->                 | ERROR   |
    {int_bool_box, a}.                     |         | {'int_bool_box', 'a'}.
                                           |         | Expression has type:   {'int_bool_box', 'a'}
                                           |         | Context expected type: #int_bool_box{}
                                           |         | 
                                           |         |   at tuple index 2:
                                           |         |   {'int_bool_box', 'a'} is not compatible with {'int_bool_box', number() | boolean()}
                                           |         |   because
                                           |         |   'a' is not compatible with number() | boolean()
                                           |         |   because
                                           |         |   'a' is not compatible with number()
                                           |         |
-spec test_tuple_record_02_neg()           |         |
    -> only_int_box().                     |         |
test_tuple_record_02_neg() ->              | ERROR   |
    {int_bool_box, a}.                     |         | {'int_bool_box', 'a'}.
                                           |         | Expression has type:   {'int_bool_box', 'a'}
                                           |         | Context expected type: only_int_box()
                                           |         | 
                                           |         |   {'int_bool_box', 'a'} is not compatible with only_int_box()
                                           |         |   because
                                           |         |   at tuple index 2:
                                           |         |   {'int_bool_box', 'a'} is not compatible with {'int_bool_box', number()}
                                           |         |   because
                                           |         |   'a' is not compatible with number()
                                           |         |
-spec test_tuple_select                    |         |
    ({int_bool_box, boolean()})            |         |
    -> boolean().                          |         |
test_tuple_select(R) ->                    | OK      |
    R#int_bool_box.inner.                  |         |
                                           |         |
-spec test_select_union                    |         |
    (only_bool_box() | only_true_box())    |         |
    -> boolean().                          |         |
test_select_union(R) ->                    | OK      |
    R#int_bool_box.inner.                  |         |
                                           |         |
-spec test_select_union_neg                |         |
    (only_bool_box() | only_true_box())    |         |
    -> true.                               |         |
test_select_union_neg(R) ->                | ERROR   |
    R#int_bool_box.inner.                  |         | ...#int_bool_box.inner.
                                           |         | Expression has type:   boolean() | 'true'
                                           |         | Context expected type: 'true'
                                           |         | 
                                           |         |   boolean() | 'true' is not compatible with 'true'
                                           |         |   because
                                           |         |   boolean() is not compatible with 'true'
                                           |         |
-record(bad_default, {                     |         |
    inner = true :: integer()              |         | 'true'.
                                           |         | Expression has type:   'true'
                                           |         | Context expected type: number()
}).                                        |         |
                                           |         |
-spec test_bad_default_neg()               |         |
    -> #bad_default{}.                     |         |
test_bad_default_neg() ->                  | ERROR   |
    #bad_default{}.                        |         |
                                           |         |
-spec test_rec_to_refined_neg()            |         |
    -> only_int_box().                     |         |
test_rec_to_refined_neg() ->               | ERROR   |
    #bad_default{inner = 42}.              |         | #bad_default{...}.
                                           |         | Expression has type:   #bad_default{}
                                           |         | Context expected type: only_int_box()
                                           |         | 
                                           |         |   #bad_default{} is not compatible with only_int_box()
                                           |         |   because
                                           |         |   #bad_default{} is not compatible with #int_bool_box{inner :: number()}
                                           |         |
-spec test_tuple_select_neg                |         |
    ({int_bool_box, integer()})            |         |
    -> integer().                          |         |
test_tuple_select_neg(R) ->                | ERROR   |
    R#bad_default.inner.                   |         | R.
                                           |         | Expression has type:   {'int_bool_box', number()}
                                           |         | Context expected type: #bad_default{}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {'int_bool_box', number()} is not compatible with {'bad_default', number()}
                                           |         |   because
                                           |         |   'int_bool_box' is not compatible with 'bad_default'
                                           |         |
-record(refined_two_fields, {              |         |
    inner :: eqwalizer:refinable(term()),  |         |
    other :: integer()                     |         |
}).                                        |         |
                                           |         |
-spec test_select_other                    |         |
    (#refined_two_fields{})                |         |
    -> integer().                          |         |
test_select_other(R) ->                    | OK      |
    R#refined_two_fields.other.            |         |
                                           |         |
-spec test_subtype_refine_neg              |         |
    (#refined_two_fields{})                |         |
    -> #refined_two_fields{inner :: intege……         |
test_subtype_refine_neg(R) -> R.           | ERROR   | R.
                                           |         | Expression has type:   #refined_two_fields{}
                                           |         | Context expected type: #refined_two_fields{inner :: number()}
                                           |         | 
                                           |         |   #refined_two_fields{} is not compatible with #refined_two_fields{inner :: number()}
                                           |         |   because
                                           |         |   term() is not compatible with number()
                                           |         |
-spec test_subtype_union_refine            |         |
    ({refined_two_fields, integer() | bool……         |
    -> (#refined_two_fields{inner :: integ……         |
     | #refined_two_fields{inner :: boolea……         |
test_subtype_union_refine(T) -> T.         | OK      |
                                           |         |
-spec test_unrec_neg() -> term().          |         |
test_unrec_neg() ->                        | ERROR   |
    L = case #foo{ id = 1, name = name} of |         |
        {foo, 1, Name} ->                  |         |
            [Name]                         |         |
    end,                                   |         |
    lists:nth(1, L) * 3.                   |         | lists:nth(1, L).
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
                                           |         |
-record(recurd, {rec :: #recurd{}}).       |         |
                                           |         |
-spec test_recurd(#recurd{}) ->            |         |
    #recurd{}.                             |         |
test_recurd(X) -> X#recurd.rec.            | OK      |
                                           |         |
-record(recurd2, {                         | INVALID |
    rec :: #recurd2{},                     |         |
    field :: _T                            |         | _T: Type variables are meaningless in record fields. Did you mean to use an alias?

}).                                        |         |
                                           |         |
-spec test_recurd2_neg(#recurd2{}) ->      | INVALID | test_recurd2_neg/1 references type with invalid definition: #recurd2{}

    #recurd2{}.                            |         |
test_recurd2_neg(X) ->                     | NO SPEC |
    X#recurd.rec.                          |         |
                                           |         |
-type loop() :: loop().                    | INVALID | recursive type loop/0 is not productive

-record(invalid, {field :: loop()}).       | INVALID | invalid references type with invalid definition: loop/0

                                           |         |
-spec unbound_select_neg(term()) -> nok.   |         |
unbound_select_neg(X) ->                   | ERROR   |
    X#invalid.field.                       |         | Unbound rec: invalid

                                           |         |
-spec unbound_select_neg2(term()) -> ok.   |         |
unbound_select_neg2(X) ->                  | ERROR   |
    _ = X#invalid.field,                   |         | Unbound rec: invalid

    ok.                                    |         |
                                           |         |
-spec unbound_update_neg(none()) -> term()……         |
unbound_update_neg(X) ->                   | ERROR   |
    X#invalid{field = 2}.                  |         | Unbound rec: invalid

                                           |         |
-record(untyped, {                         |         |
    field1 :: atom(),                      |         |
    field2                                 |         |
}).                                        |         |
                                           |         |
-spec inspect_untyped(#untyped{})          |         |
        -> atom().                         |         |
inspect_untyped(U) ->                      | ERROR   |
    Field2 = U#untyped.field2,             |         |
    eqwalizer:reveal_type(Field2),         |         | term()

    Field2.                                |         |
                                           |         |
-type bin_tuple() :: {                     |         |
    binary(),                              |         |
    binary()                               |         |
}.                                         |         |
                                           |         |
-type bin_triple() :: {                    |         |
    binary(),                              |         |
    binary(),                              |         |
    binary()                               |         |
}.                                         |         |
                                           |         |
-type rec() :: misc:my_record_hidden().    |         |
                                           |         |
-spec atomize2(                            |         |
    rec() | bin_tuple()                    |         |
) -> atom().                               |         |
atomize2({B, _}) ->                        | OK      |
    binary_to_atom(B);                     |         |
atomize2(Rec) ->                           |         |
    misc:atomize(Rec).                     |         |
                                           |         |
-spec atomize3(                            |         |
    rec() | bin_triple()                   |         |
) -> atom().                               |         |
atomize3({B, _, _}) ->                     | ERROR   |
    binary_to_atom(B);                     |         | B.
                                           |         | Expression has type:   'my_record' | binary()
                                           |         | Context expected type: binary()
                                           |         | 
                                           |         |   'my_record' | binary() is not compatible with binary()
                                           |         |   because
                                           |         |   'my_record' is not compatible with binary()
atomize3(Rec) ->                           |         |
    misc:atomize(Rec).                     |         |
                                           |         |
-spec rec_unsound(#foo{})                  |         |
        -> types1:foo_rec().               |         |
rec_unsound(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-record(two_fields, {                      |         |
  id1 :: atom(),                           |         |
  id2 :: atom()                            |         |
}).                                        |         |
                                           |         |
-spec fields_equal(#two_fields{})          |         |
  -> boolean().                            |         |
fields_equal(X)                            | OK      |
  when X =:= #two_fields{_ = id} ->        |         |
  true;                                    |         |
fields_equal(_) ->                         |         |
  false.                                   |         |
                                           |         |
-record(two_ref, {                         |         |
    a :: eqwalizer:refinable(term()),      |         |
    b :: eqwalizer:refinable(term())       |         |
}).                                        |         |
                                           |         |
-type two_ref1() :: #two_ref{a :: atom(), ……         |
                                           |         |
-spec narrow1(#two_ref{}, atom()) -> two_r……         |
narrow1(F, A) ->                           | OK      |
    F1 = F#two_ref{a = A, b = A},          |         |
    F1.                                    |         |
                                           |         |
-spec narrow2(#two_ref{}, atom()) -> two_r……         |
narrow2(F, A) ->                           | OK      |
    F1 = F#two_ref{a = A},                 |         |
    F2 = F1#two_ref{b = A},                |         |
    F2.                                    |         |
                                           |         |
-type two_ref2() :: #two_ref{a :: integer(……         |
-type two_ref3() :: #two_ref{b :: boolean(……         |
                                           |         |
-spec narrow3({two_ref1(), two_ref2()}) ->……         |
narrow3({X, X}) -> X.                      | OK      |
                                           |         |
-spec narrow4({two_ref1(), two_ref3()}) ->……         |
narrow4({X, X}) -> {X#two_ref.a, X#two_ref…… OK      |
                                           |         |
-spec narrow5_neg({two_ref1(), two_ref3()}……         |
narrow5_neg({X, X}) -> X.                  | ERROR   | X.
                                           |         | Expression has type:   #two_ref{b :: boolean(), a :: atom()}
                                           |         | Context expected type: 'ok'
                                           |         |
-spec narrow6(two_ref1() | two_ref2()) -> ……         |
narrow6(R = #two_ref{a = _, b = _}) -> R.  | OK      |
                                           |         |
-spec mk_foo() -> #foo{} | none().         |         |
mk_foo() ->                                | OK      |
    #foo{id = 1, name = name}.             |         |
                                           |         |
-spec un_foo() -> atom().                  |         |
un_foo() ->                                | ERROR   |
    Rec = mk_foo(),                        |         |
    #foo{id = Id} = Rec,                   |         |
    Id.                                    |         | Id.
                                           |         | Expression has type:   number() | none()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   number() | none() is not compatible with atom()
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
-spec mk_two_ref() -> #two_ref{} | none(). |         |
mk_two_ref() ->                            | OK      |
    #two_ref{}.                            |         |
                                           |         |
-spec un_two_ref1() -> atom().             |         |
un_two_ref1() ->                           | ERROR   |
    Rec = mk_two_ref(),                    |         |
    Rec#two_ref.a.                         |         | ...#two_ref.a.
                                           |         | Expression has type:   term() | none()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   term() | none() is not compatible with atom()
                                           |         |   because
                                           |         |   term() is not compatible with atom()
                                           |         |
-spec un_two_ref2() -> atom().             |         |
un_two_ref2() ->                           | ERROR   |
    Rec = mk_two_ref(),                    |         |
    #two_ref{a = A} = Rec,                 |         |
    A.                                     |         | A.
                                           |         | Expression has type:   term() | none()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   term() | none() is not compatible with atom()
                                           |         |   because
                                           |         |   term() is not compatible with atom()
