%%% Copyright (c) Meta Platforms, Inc. and……         |
%%%                                        |         |
%%% This source code is licensed under the……         |
%%% the LICENSE file in the root directory……         |
                                           |         |
-module(t_maps).                           |         |
                                           |         |
-compile([export_all, nowarn_export_all]). |         |
                                           |         |
-export_type([                             |         |
    a/0,                                   |         |
    n/0                                    |         |
]).                                        |         |
                                           |         |
-type b() :: boolean().                    |         |
-type n() :: number().                     |         |
-type a() :: atom().                       |         |
                                           |         |
-spec empty_map_01() -> #{}.               |         |
empty_map_01() -> #{}.                     | OK      |
                                           |         |
-spec empty_map_02() -> map().             |         |
empty_map_02() -> #{}.                     | OK      |
                                           |         |
-spec empty_map_03() -> term().            |         |
empty_map_03() -> #{}.                     | OK      |
                                           |         |
-spec dict_map_01() ->                     |         |
    #{integer() => atom()}.                |         |
dict_map_01() ->                           | OK      |
    #{0 => zero, 1 => one}.                |         |
                                           |         |
-spec dict_map_02_neg() ->                 |         |
    #{integer() => atom()}.                |         |
dict_map_02_neg() ->                       | ERROR   |
    #{0 => 1, 1 => 2}.                     |         | #{..}.
                                           |         | Expression has type:   #D{number() => number()}
                                           |         | Context expected type: #D{number() => atom()}
                                           |         | 
                                           |         |   #D{number() => number()} is not compatible with #D{number() => atom()}
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
-spec dict_map_03_neg() ->                 |         |
    #{integer() => atom()}.                |         |
dict_map_03_neg() ->                       | ERROR   |
    #{0 => zero, 1 => 2}.                  |         | #{..}.
                                           |         | Expression has type:   #D{number() => 'zero' | number()}
                                           |         | Context expected type: #D{number() => atom()}
                                           |         | 
                                           |         |   #D{number() => 'zero' | number()} is not compatible with #D{number() => atom()}
                                           |         |   because
                                           |         |   'zero' | number() is not compatible with atom()
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
-spec dict_map_04() ->                     |         |
    #{integer() => atom() | number()}.     |         |
dict_map_04() ->                           | OK      |
    #{0 => zero, 1 => 2}.                  |         |
                                           |         |
-spec shape_01() ->                        |         |
    #{zero := number(), one => number()}.  |         |
shape_01() ->                              | OK      |
    #{zero => 0, one => 1}.                |         |
                                           |         |
-spec shape_02_neg() ->                    |         |
    #{zero := number(), one => number()}.  |         |
shape_02_neg() ->                          | ERROR   |
    #{zero => 0, one => one}.              |         | #{..}.
                                           |         | Expression has type:   #S{one := 'one', zero := number()}
                                           |         | Context expected type: #S{one => number(), zero := number()}
                                           |         | 
                                           |         |   at shape key 'one':
                                           |         |   #S{one := 'one', zero := number()} is not compatible with #S{one => number(), zero := number()}
                                           |         |   because
                                           |         |   'one' is not compatible with number()
                                           |         |
% only atom keys can be updated            |         |
% unconditionally                          |         |
-spec update_req_non_atom_neg              |         |
    (map()) -> map().                      |         |
update_req_non_atom_neg(M) ->              | OK      |
    M#{1 := 1}.                            |         |
                                           |         |
% it is not allowed to use                 |         |
% a dict for unconditional update          |         |
-spec dict_update_req_neg                  |         |
    (map()) -> map().                      |         |
dict_update_req_neg(M) ->                  | OK      |
    M#{one := 1}.                          |         |
                                           |         |
-spec empty_update1                        |         |
    (map()) -> map().                      |         |
empty_update1(M) ->                        | OK      |
    M#{}.                                  |         |
                                           |         |
-spec empty_update2_neg                    |         |
    (term()) -> map().                     |         |
empty_update2_neg(M) ->                    | ERROR   |
    M#{}.                                  |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
                                           |         |
-spec empty_update3                        |         |
    () -> #{}.                             |         |
empty_update3() ->                         | OK      |
    (#{})#{}.                              |         |
                                           |         |
-spec dict_update1                         |         |
    (#{atom() => true})                    |         |
  -> #{atom() => boolean()}.               |         |
dict_update1(D) ->                         | OK      |
    D#{foo => false}.                      |         |
                                           |         |
-spec dict_update2                         |         |
    (#{atom() => true})                    |         |
  -> map().                                |         |
dict_update2(D) ->                         | OK      |
    D#{1 => bar}.                          |         |
                                           |         |
-spec shape_update1                        |         |
    (#{foo => b(), bar => n()})            |         |
    -> #{foo => b(), bar => b()}.          |         |
shape_update1(S) ->                        | OK      |
    S#{bar => true}.                       |         |
                                           |         |
-spec shape_update2                        |         |
    (#{foo => b(), bar := n()})            |         |
        -> #{foo => b(), bar := b()}.      |         |
shape_update2(S) ->                        | OK      |
    S#{bar := true}.                       |         |
                                           |         |
-spec shape_update3_neg                    |         |
    (#{foo => b(), bar => n()})            |         |
        -> #{foo => b(), bar := b()}.      |         |
shape_update3_neg(S) ->                    | OK      |
    S#{bar := true}.                       |         |
                                           |         |
-spec shape_update4_neg                    |         |
    (term()) -> #{bar := b()}.             |         |
shape_update4_neg(S) ->                    | ERROR   |
    S#{bar := true}.                       |         | S.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
                                           |         |
-spec meet_dict1                           |         |
    (#{b() | n() => term()}, #{a() => term……         |
     #{b() => term()}.                     |         |
meet_dict1(D, D) -> D.                     | OK      |
                                           |         |
-spec meet_dict2_neg                       |         |
    (#{b() | n() => term()}, #{a() => term……         |
    #{n() => term()}.                      |         |
meet_dict2_neg(D, D) -> D.                 | ERROR   | D.
                                           |         | Expression has type:   #D{b() => term()}
                                           |         | Context expected type: #D{n() => term()}
                                           |         | 
                                           |         |   #D{b() => term()} is not compatible with #D{n() => term()}
                                           |         |   because
                                           |         |   b() is not compatible with n()
                                           |         |   because
                                           |         |   boolean() is not compatible with n()
                                           |         |
-spec meet_shape1                          |         |
    (#{a := a()}, #{a := b()}) ->          |         |
    #{a := b()}.                           |         |
meet_shape1(S, S) -> S.                    | OK      |
                                           |         |
-spec meet_shape2_neg                      |         |
    (#{a := a()}, #{a := b()}) ->          |         |
    #{a := n()}.                           |         |
meet_shape2_neg(S, S) -> S.                | ERROR   | S.
                                           |         | Expression has type:   #S{a := b()}
                                           |         | Context expected type: #S{a := n()}
                                           |         | 
                                           |         |   at shape key 'a':
                                           |         |   #S{a := b()} is not compatible with #S{a := n()}
                                           |         |   because
                                           |         |   b() is not compatible with n()
                                           |         |   because
                                           |         |   boolean() is not compatible with n()
                                           |         |
-spec meet_shape3_neg                      |         |
    (#{a := a()}, #{a := b()}) ->          |         |
    #{a => n()}.                           |         |
meet_shape3_neg(S, S) -> S.                | ERROR   | S.
                                           |         | Expression has type:   #S{a := b()}
                                           |         | Context expected type: #S{a => n()}
                                           |         | 
                                           |         |   at shape key 'a':
                                           |         |   #S{a := b()} is not compatible with #S{a => n()}
                                           |         |   because
                                           |         |   b() is not compatible with n()
                                           |         |   because
                                           |         |   boolean() is not compatible with n()
                                           |         |
-spec meet_shape4                          |         |
    (#{a => a()}, #{a => b() | n()}) ->    |         |
    #{a => b()}.                           |         |
meet_shape4(S, S) -> S.                    | OK      |
                                           |         |
-spec meet_shape5_neg                      |         |
    (#{a => a()}, #{a => b() | n()}) ->    |         |
    #{a := b()}.                           |         |
meet_shape5_neg(S, S) -> S.                | ERROR   | S.
                                           |         | Expression has type:   #S{a => b()}
                                           |         | Context expected type: #S{a := b()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    a := ...
                                           |         | +    a => ...
                                           |         |   }
                                           |         |
-spec meet_shape6                          |         |
    (#{a := a()}, #{a => b() | n()}) ->    |         |
    #{a := b()}.                           |         |
meet_shape6(S, S) -> S.                    | OK      |
                                           |         |
-spec meet_shape7                          |         |
    (#{a := a()}, #{b := b()}) ->          |         |
    none().                                |         |
meet_shape7(S, S) -> S.                    | OK      |
                                           |         |
% this seems to be really cool             |         |
-spec u_shape1                             |         |
    (#{a := a()} | #{a := b(), b := b()}) ……         |
    (#{a := n()} | #{a := n(), b := b()}). |         |
u_shape1(S) ->                             | OK      |
    S#{a := 1}.                            |         |
                                           |         |
-spec u_shape2_neg                         |         |
    (#{a := a()}) ->                       |         |
    (#{a := a(), b := a()}).               |         |
u_shape2_neg(S) ->                         | OK      |
    S#{b := foo}.                          |         |
                                           |         |
-spec u_shape3                             |         |
    (#{a := a()}) ->                       |         |
    (#{a := a(), b := a()}).               |         |
u_shape3(S) ->                             | OK      |
    S#{b => foo}.                          |         |
                                           |         |
-spec u_empty1                             |         |
    (#{}) ->                               |         |
    (#{n() => a()}).                       |         |
u_empty1(S) ->                             | OK      |
    S#{1 => one}.                          |         |
                                           |         |
-spec shape@dict1                          |         |
    (#{a := a()}, a(), a()) ->             |         |
    (#{a() => a()}).                       |         |
shape@dict1(S, K, V) ->                    | OK      |
    S#{K => V}.                            |         |
                                           |         |
-spec shape@dict2_neg                      |         |
    (#{a := a()}, n(), a()) ->             |         |
    (#{a() => a()}).                       |         |
shape@dict2_neg(S, K, V) ->                | ERROR   |
    S#{K => V}.                            |         | ..#{..}.
                                           |         | Expression has type:   #D{atom() | n() => a()}
                                           |         | Context expected type: #D{a() => a()}
                                           |         | 
                                           |         |   #D{atom() | n() => a()} is not compatible with #D{a() => a()}
                                           |         |   because
                                           |         |   atom() | n() is not compatible with a()
                                           |         |   because
                                           |         |   atom() | n() is not compatible with atom()
                                           |         |   because
                                           |         |   n() is not compatible with atom()
                                           |         |
-spec shape@dict3_neg                      |         |
    (#{a := a()}, n(), a()) ->             |         |
    (#{n() => a()}).                       |         |
shape@dict3_neg(S, K, V) ->                | ERROR   |
    S#{K => V}.                            |         | ..#{..}.
                                           |         | Expression has type:   #D{atom() | n() => a()}
                                           |         | Context expected type: #D{n() => a()}
                                           |         | 
                                           |         |   #D{atom() | n() => a()} is not compatible with #D{n() => a()}
                                           |         |   because
                                           |         |   atom() | n() is not compatible with n()
                                           |         |   because
                                           |         |   atom() | n() is not compatible with number()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
                                           |         |
-spec shape@dict4_neg                      |         |
    (Shape, n(), a()) ->                   |         |
    (Dict) when                            |         |
    Shape :: #{a := a()},                  |         |
    Dict :: #{n() => a()}.                 |         |
shape@dict4_neg(S, K, V) ->                | ERROR   |
    S#{K => V}.                            |         | ..#{..}.
                                           |         | Expression has type:   #D{atom() | n() => a()}
                                           |         | Context expected type: #D{n() => a()}
                                           |         | 
                                           |         |   #D{atom() | n() => a()} is not compatible with #D{n() => a()}
                                           |         |   because
                                           |         |   atom() | n() is not compatible with n()
                                           |         |   because
                                           |         |   atom() | n() is not compatible with number()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
                                           |         |
-spec shape@dict5_neg                      |         |
    (Shape, n(), a()) ->                   |         |
    (Dict) when                            |         |
    Shape :: #{a => a()},                  |         |
    Dict :: #{n() => a()}.                 |         |
shape@dict5_neg(S, K, V) ->                | ERROR   |
    S#{K => V}.                            |         | ..#{..}.
                                           |         | Expression has type:   #D{atom() | n() => a()}
                                           |         | Context expected type: #D{n() => a()}
                                           |         | 
                                           |         |   #D{atom() | n() => a()} is not compatible with #D{n() => a()}
                                           |         |   because
                                           |         |   atom() | n() is not compatible with n()
                                           |         |   because
                                           |         |   atom() | n() is not compatible with number()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
                                           |         |
-type foo_bar(F, B) ::                     |         |
    #{foo := F, bar := B}.                 |         |
                                           |         |
-type foo_bar_opt(F, B) ::                 |         |
    #{foo => F, bar => B}.                 |         |
                                           |         |
-spec foo_bar_u                            |         |
    (foo_bar(F1, B1), F1, B1) ->           |         |
    foo_bar(F1, B1).                       |         |
foo_bar_u(FB, F1, B1) ->                   | OK      |
    FB#{foo := F1, bar := B1}.             |         |
                                           |         |
-spec foo_bar_u_neg                        |         |
    (foo_bar(F1, B1), F1, B1) ->           |         |
    foo_bar(B1, F1).                       |         |
foo_bar_u_neg(FB, F1, B1) ->               | ERROR   |
    FB#{foo := F1, bar := B1}.             |         | ..#{..}.
                                           |         | Expression has type:   #S{bar := B1, foo := F1}
                                           |         | Context expected type: foo_bar(B1, F1)
                                           |         | 
                                           |         |   #S{bar := B1, foo := F1} is not compatible with foo_bar(B1, F1)
                                           |         |   because
                                           |         |   at shape key 'bar':
                                           |         |   #S{bar := B1, foo := F1} is not compatible with #S{bar := F1, foo := B1}
                                           |         |   because
                                           |         |   B1 is not compatible with F1
                                           |         |
-spec foo_bar_u_opt                        |         |
    (foo_bar_opt(F1, B1), F1, B1) ->       |         |
    foo_bar(F1, B1).                       |         |
foo_bar_u_opt(FB, F1, B1) ->               | OK      |
    FB#{foo => F1, bar => B1}.             |         |
                                           |         |
-spec foo_bar_u_opt_neg                    |         |
    (foo_bar_opt(F1, B1), F1, B1) ->       |         |
    foo_bar_opt(B1, F1).                   |         |
foo_bar_u_opt_neg(FB, F1, B1) ->           | ERROR   |
    FB#{foo => F1, bar => B1}.             |         | ..#{..}.
                                           |         | Expression has type:   #S{bar := B1, foo := F1}
                                           |         | Context expected type: foo_bar_opt(B1, F1)
                                           |         | 
                                           |         |   #S{bar := B1, foo := F1} is not compatible with foo_bar_opt(B1, F1)
                                           |         |   because
                                           |         |   at shape key 'bar':
                                           |         |   #S{bar := B1, foo := F1} is not compatible with #S{bar => F1, foo => B1}
                                           |         |   because
                                           |         |   B1 is not compatible with F1
                                           |         |
-type kv(K, V) :: #{K => V}.               |         |
                                           |         |
-spec kvs(kv(K1, V1), K2, V2) ->           |         |
    kv(K1 | K2, V1 | V2).                  |         |
kvs(Dict, K2, V2) ->                       | OK      |
    Dict#{K2 => V2}.                       |         |
                                           |         |
-spec kvs_neg(kv(K1, V1), K2, V2) ->       |         |
    kv(K1 | K2, V1 | V2).                  |         |
kvs_neg(Dict, K2, V2) ->                   | ERROR   |
    Dict#{V2 => K2}.                       |         | ..#{..}.
                                           |         | Expression has type:   #D{K1 | V2 => V1 | K2}
                                           |         | Context expected type: kv(K1 | K2, V1 | V2)
                                           |         | 
                                           |         |   #D{K1 | V2 => V1 | K2} is not compatible with kv(K1 | K2, V1 | V2)
                                           |         |   because
                                           |         |   #D{K1 | V2 => V1 | K2} is not compatible with #D{K1 | K2 => V1 | V2}
                                           |         |   because
                                           |         |   K1 | V2 is not compatible with K1 | K2
                                           |         |   because
                                           |         |   V2 is not compatible with K1 | K2
                                           |         |
-spec lit_type(a) ->                       |         |
    #{a => number()}.                      |         |
lit_type(A) -> #{A => 3}.                  | OK      |
                                           |         |
-spec needs_shape_a                        |         |
    (#{a := term()}) -> ok.                |         |
needs_shape_a(_) -> ok.                    | OK      |
                                           |         |
-spec needs_shape_ab                       |         |
    (#{a := term(), b := term()}) -> ok.   |         |
needs_shape_ab(_) -> ok.                   | OK      |
                                           |         |
-spec shapeab_neg(#{a := 3}) -> ok.        |         |
shapeab_neg(X) ->                          | ERROR   |
    needs_shape_a(X),                      |         |
    needs_shape_a(X#{b => hello}).         |         | ..#{..}.
                                           |         | Expression has type:   #S{a := number(), b := 'hello'}
                                           |         | Context expected type: #S{a := term()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    b := ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec shape_ab(#{a := term()}) -> ok.      |         |
shape_ab(X) ->                             | OK      |
    needs_shape_a(X),                      |         |
    needs_shape_ab(X#{b => hello}).        |         |
                                           |         |
-spec slice_map(#{a() => n()} | [a()])     |         |
    -> #{a() => n()}.                      |         |
slice_map(#{} = M) -> M;                   | OK      |
slice_map(_) -> #{}.                       |         |
                                           |         |
-spec get_kv(term(), #{a() => n()})        |         |
    -> {a(), n()}.                         |         |
get_kv(K, M) ->                            | OK      |
    case M of                              |         |
        #{K := V} -> {K, V};               |         |
        _ -> {not_found, 0}                |         |
    end.                                   |         |
                                           |         |
-spec get_kv_neg(term(), #{a() => n()})    |         |
        -> {n(), a()}.                     |         |
get_kv_neg(K, M) ->                        | ERROR   |
    case M of                              |         |
        #{K := V} -> {K, V};               |         | {K, V}.
                                           |         | Expression has type:   {a(), n()}
                                           |         | Context expected type: {n(), a()}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {a(), n()} is not compatible with {n(), a()}
                                           |         |   because
                                           |         |   a() is not compatible with n()
                                           |         |   because
                                           |         |   atom() is not compatible with n()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
        _ -> {0, not_found}                |         |
    end.                                   |         |
                                           |         |
-spec f_shape1(#{a => a(), n => n()})      |         |
    -> {n(), a()}.                         |         |
f_shape1(#{a := A, n := N}) ->             | OK      |
    {N, A};                                |         |
f_shape1(#{a := A}) -> {0, A};             |         |
f_shape1(#{n := N}) -> {N, n}.             |         |
                                           |         |
-spec f_shape2_neg(#{a => a(), n => n()})  |         |
        -> {n(), a()}.                     |         |
f_shape2_neg(#{a := A, n := N}) ->         | ERROR   |
    {A, N}.                                |         | {A, N}.
                                           |         | Expression has type:   {a(), n()}
                                           |         | Context expected type: {n(), a()}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {a(), n()} is not compatible with {n(), a()}
                                           |         |   because
                                           |         |   a() is not compatible with n()
                                           |         |   because
                                           |         |   atom() is not compatible with n()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
                                           |         |
-spec to_map1(term()) -> map().            |         |
to_map1(#{} = M) -> M;                     | OK      |
to_map1(_) -> #{}.                         |         |
                                           |         |
-spec to_map2(#{K => V} | {K, V})          |         |
    -> #{K => V}.                          |         |
to_map2(#{} = M) -> M;                     | OK      |
to_map2({K, V}) -> #{K => V}.              |         |
                                           |         |
-spec to_map3_neg(#{V => K} | {K, V})      |         |
        -> #{K => V}.                      |         |
to_map3_neg(#{} = M) -> M;                 | ERROR   | M.
                                           |         | Expression has type:   #D{V => K}
                                           |         | Context expected type: #D{K => V}
                                           |         | 
                                           |         |   #D{V => K} is not compatible with #D{K => V}
                                           |         |   because
                                           |         |   V is not compatible with K
to_map3_neg({K, V}) -> #{K => V}.          |         |
                                           |         |
-spec to_map4(                             |         |
    #{a() => n()}                          |         |
    | #{n() => a()}                        |         |
    | #{id => id | no_id}                  |         |
    | {}                                   |         |
) -> #{a() | n() => a() | n()}.            |         |
to_map4(#{} = M) -> M.                     | OK      |
                                           |         |
-spec to_map5_neg(                         |         |
    #{a() => n()}                          |         |
    | #{n() => a()}                        |         |
    | #{id => id | no_id}                  |         |
    | {}                                   |         |
) -> #{a() | n() => a()}.                  |         |
to_map5_neg(#{} = M) -> M.                 | ERROR   | M.
                                           |         | Expression has type:   #D{a() => n()} | #D{n() => a()} | #S{id => 'id' | 'no_id'}
                                           |         | Context expected type: #D{a() | n() => a()}
                                           |         | 
                                           |         |   #D{a() => n()} | #D{n() => a()} | #S{id => 'id' | 'no_id'} is not compatible with #D{a() | n() => a()}
                                           |         |   because
                                           |         |   #D{a() => n()} is not compatible with #D{a() | n() => a()}
                                           |         |   because
                                           |         |   n() is not compatible with a()
                                           |         |   because
                                           |         |   number() is not compatible with a()
                                           |         |
-spec no_map(                              |         |
    [] | {}                                |         |
) -> none().                               |         |
no_map(#{} = M) -> M.                      | OK      |
                                           |         |
-spec no_prop(                             |         |
    #{a := a(), b := b()}                  |         |
) -> none().                               |         |
no_prop(#{foo := V}) -> V.                 | OK      |
                                           |         |
-spec shape_atom_key(                      |         |
    term(), #{a := a(), b := b()}          |         |
) -> {a(), a()}.                           |         |
shape_atom_key(K, Shape) ->                | OK      |
    case Shape of                          |         |
        #{K := V} -> {K, V};               |         |
        _ -> {undef, undef}                |         |
    end.                                   |         |
                                           |         |
-spec shape_atom_key_neg(                  |         |
    term(), #{a := a(), b := b()}          |         |
) -> {n(), a()}.                           |         |
shape_atom_key_neg(K, Shape) ->            | ERROR   |
    case Shape of                          |         |
        #{K := V} -> {K, V};               |         | {K, V}.
                                           |         | Expression has type:   {atom(), a()}
                                           |         | Context expected type: {n(), a()}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {atom(), a()} is not compatible with {n(), a()}
                                           |         |   because
                                           |         |   atom() is not compatible with n()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
        _ -> {0, undef}                    |         |
    end.                                   |         |
                                           |         |
-spec no_kv_neg(                           |         |
    K, [{K, V}]                            |         |
) -> {K, V}.                               |         |
no_kv_neg(K, Props) ->                     | OK      |
    case Props of                          |         |
        #{K := V} -> {K, V}                |         |
    end.                                   |         |
                                           |         |
-spec k_union1(                            |         |
    term(), #{pid() => term()} | #{number(……         |
) -> pid() | number() | undefined.         |         |
k_union1(K, Dict) ->                       | OK      |
    case Dict of                           |         |
        #{K := _} -> K;                    |         |
        _ -> undefined                     |         |
    end.                                   |         |
                                           |         |
-spec no_key(                              |         |
    term(), a() | [{a(), term()}]          |         |
) -> undefined.                            |         |
no_key(K, Dict) ->                         | OK      |
    case Dict of                           |         |
        #{K := _} -> K;                    |         |
        _ -> undefined                     |         |
    end.                                   |         |
                                           |         |
-spec no_val(                              |         |
    term(), a() | [{a(), term()}]          |         |
) -> undefined.                            |         |
no_val(K, Dict) ->                         | OK      |
    case Dict of                           |         |
        #{K := V} -> V;                    |         |
        _ -> undefined                     |         |
    end.                                   |         |
                                           |         |
-spec val1(                                |         |
    #{a := a()} | #{a := n()}              |         |
) -> a() | n().                            |         |
val1(#{a := V}) -> V.                      | OK      |
                                           |         |
-spec val2(                                |         |
    #{a := a()} | #{b := n()}              |         |
) -> a().                                  |         |
val2(#{a := V}) -> V.                      | OK      |
                                           |         |
-spec val3(                                |         |
    #{a1 := a()} | #{b1 := n()}            |         |
) -> none().                               |         |
val3(#{a := V}) -> V.                      | OK      |
                                           |         |
-spec val4(                                |         |
    {a(), a()}                             |         |
) -> none().                               |         |
val4(#{a := V}) -> V.                      | OK      |
                                           |         |
-spec val5(                                |         |
    a(), {a()} | {a(), a()}                |         |
) -> none().                               |         |
val5(K, M) ->                              | OK      |
    case M of                              |         |
        #{K := V} -> V                     |         |
    end.                                   |         |
                                           |         |
-spec guard1                               |         |
    (#{a() => a()} | a())                  |         |
    -> #{a() => a()}.                      |         |
guard1(M) when is_map(M) -> M;             | OK      |
guard1(A) when is_atom(A) -> #{A => A}.    |         |
                                           |         |
-spec guard2(a()) -> none().               |         |
guard2(M) when is_map(M) -> M.             | OK      |
                                           |         |
-spec guard3                               |         |
    (term()) -> map().                     |         |
guard3(A) when is_map(A#{}) -> A.          | OK      |
                                           |         |
-spec guard4                               |         |
    (term()) -> map().                     |         |
guard4(A) when is_map(A#{a := 1}) -> A.    | OK      |
                                           |         |
-spec guard5                               |         |
    (term(), term()) -> {map(), map()}.    |         |
guard5(M1, M2) when                        | OK      |
    M1#{} == M2#{} -> {M1, M2}.            |         |
                                           |         |
-spec guard6                               |         |
    (term(), term()) -> {map(), map()}.    |         |
guard6(M1, M2) when                        | OK      |
    M1#{a := 1} == M2#{a := 1}             |         |
    -> {M1, M2}.                           |         |
                                           |         |
-spec guard7                               |         |
    (term()) -> map().                     |         |
guard7(M) when M#{a => 1} == #{a => 1}     | OK      |
    -> M.                                  |         |
                                           |         |
-spec refine(                              |         |
    #{a := term(), b => atom()},           |         |
    #{a => atom(), b := term()}            |         |
) -> #{a := atom(), b := atom()}.          |         |
refine(S1, S1) -> S1.                      | OK      |
                                           |         |
%% checking constraints                    |         |
-spec c_map1() -> #{term() => Atom}        |         |
    when Atom :: atom().                   |         |
c_map1() -> #{ok => ok}.                   | OK      |
                                           |         |
-spec c_map2() -> #{Key => Atom}           |         |
    when Key :: atom(), Atom :: atom().    |         |
c_map2() -> #{key => ok}.                  | OK      |
                                           |         |
-spec update_none1(none()) -> none().      |         |
update_none1(N) -> N#{a := 1}.             | OK      |
                                           |         |
-spec update_none2(none()) -> none().      |         |
update_none2(N) -> N#{a => 1}.             | OK      |
                                           |         |
%% "smaller maps"                          |         |
-spec sub_1(#{}) -> #{a => atom()}.        |         |
sub_1(M) -> M.                             | OK      |
                                           |         |
-spec sub_2(#{a := atom()}) ->             |         |
    #{a => atom(), n => number()}.         |         |
sub_2(M) -> M.                             | OK      |
                                           |         |
-spec sub_3_neg(#{a := atom()}) ->         |         |
    #{a => atom(), n := number()}.         |         |
sub_3_neg(M) -> M.                         | ERROR   | M.
                                           |         | Expression has type:   #S{a := atom()}
                                           |         | Context expected type: #S{a => atom(), n := number()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    n := ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec test_update_with_1(                  |         |
    #{string() => binary()},               |         |
    fun((binary()) -> atom())              |         |
) -> #{string() => binary() | atom()}.     |         |
test_update_with_1(Map, F) ->              | OK      |
    maps:update_with("", F, Map).          |         |
                                           |         |
-spec test_update_with_2(                  |         |
    #{a := b},                             |         |
    fun((b) -> c)                          |         |
) -> #{a => b | c }.                       |         |
test_update_with_2(Map, F) ->              | OK      |
    maps:update_with(a, F, Map).           |         |
                                           |         |
-spec test_update_with_3(                  |         |
    #{string() => binary()},               |         |
    fun((binary()) -> atom())              |         |
) -> #{string() => binary() | atom()}.     |         |
test_update_with_3(Map, F) ->              | OK      |
    maps:update_with("", F, a, Map).       |         |
                                           |         |
-spec test_update_with_4(                  |         |
    #{a := b},                             |         |
    fun((b) -> c)                          |         |
) -> #{a => b | c }.                       |         |
test_update_with_4(Map, F) ->              | ERROR   |
    maps:update_with(a, F, a, Map).        |         | maps:update_with('a', F, 'a', Map).
                                           |         | Expression has type:   dict  map #D{'a' => 'b' | 'c' | 'a'}
                                           |         | Context expected type: shape map #S{a => 'b' | 'c'}
                                           |         |
-type rec_shape() :: #{                    |         |
    item := rec_shape() | undefined        |         |
}.                                         |         |
                                           |         |
-type rec_shape_v2() :: #{                 |         |
  item_v2 := rec_shape_v2() | undefined    |         |
}.                                         |         |
                                           |         |
-spec rec_shape_1(                         |         |
    #{                                     |         |
        item := #{                         |         |
            item :=                        |         |
                undefined                  |         |
        }                                  |         |
    }                                      |         |
) -> rec_shape().                          |         |
rec_shape_1(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec rec_shape_2(rec_shape()) ->          |         |
    undefined | #{                         |         |
    item := undefined | #{                 |         |
        item :=                            |         |
            undefined | rec_shape()        |         |
        }                                  |         |
    }.                                     |         |
rec_shape_2(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec rec_shape_3_neg(                     |         |
    rec_shape()                            |         |
) -> rec_shape_v2().                       |         |
rec_shape_3_neg(X) ->                      | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   rec_shape()
                                           |         | Context expected type: rec_shape_v2()
                                           |         | 
                                           |         |   rec_shape() is not compatible with rec_shape_v2()
                                           |         |   because
                                           |         |   #S{item := rec_shape() | 'undefined'} is not compatible with rec_shape_v2()
                                           |         |   because
                                           |         |   #S{item := rec_shape() | 'undefined'} is not compatible with #S{item_v2 := rec_shape_v2() | 'undefined'}
                                           |         |   These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    item    := ...
                                           |         | -    item_v2 := ...
                                           |         |   }
                                           |         |
-type gen_shape(T) :: #{                   |         |
    item := T | gen_shape(T)               |         |
}.                                         |         |
                                           |         |
-type gen_shape_v2(T) :: #{                |         |
  item_v2 := T | gen_shape_v2(T)           |         |
}.                                         |         |
                                           |         |
-type gen_shape_expanded(T) :: #{          |         |
    item := T | #{                         |         |
        item := T | gen_shape_expanded(T)  |         |
    }                                      |         |
}.                                         |         |
                                           |         |
-spec gen_shape_1(                         |         |
    #{ item := a }                         |         |
) -> gen_shape(a | b).                     |         |
gen_shape_1(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec gen_shape_2(                         |         |
    #{ item := a }                         |         |
) -> gen_shape(a | b).                     |         |
gen_shape_2(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec gen_shape_3(gen_shape(a)) ->         |         |
    #{                                     |         |
        item := a | #{                     |         |
            item :=                        |         |
                a | gen_shape(a)           |         |
        }                                  |         |
    }.                                     |         |
gen_shape_3(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec gen_shape_4(                         |         |
    #{                                     |         |
        item := a | #{                     |         |
            item :=                        |         |
                a | gen_shape(a)           |         |
        }                                  |         |
    }                                      |         |
) -> gen_shape(a).                         |         |
gen_shape_4(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec gen_shape_5_neg                      |         |
(gen_shape(a | b)) ->                      |         |
    a | #{                                 |         |
        item := a | #{                     |         |
            item :=                        |         |
                a | gen_shape(a)           |         |
        }                                  |         |
    }.                                     |         |
gen_shape_5_neg(X) ->                      | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   gen_shape('a' | 'b')
                                           |         | Context expected type: 'a' | #S{item := 'a' | #S{item := 'a' | gen_shape('a')}}
                                           |         | 
                                           |         |   gen_shape('a' | 'b') is not compatible with 'a' | #S{item := 'a' | #S{item := 'a' | gen_shape('a')}}
                                           |         |   because
                                           |         |   #S{item := 'a' | 'b' | gen_shape('a' | 'b')} is not compatible with 'a' | #S{item := 'a' | #S{item := 'a' | gen_shape('a')}}
                                           |         |   because
                                           |         |   #S{item := 'a' | 'b' | gen_shape('a' | 'b')} is not compatible with 'a'
                                           |         |
-spec gen_shape_6                          |         |
    (gen_shape_expanded(a)) ->             |         |
    gen_shape(a | b).                      |         |
gen_shape_6(X) ->                          | OK      |
    X.                                     |         |
                                           |         |
-spec gen_shape_7_neg                      |         |
    (gen_shape_v2(a)) ->                   |         |
    gen_shape(a).                          |         |
gen_shape_7_neg(X) ->                      | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   gen_shape_v2('a')
                                           |         | Context expected type: gen_shape('a')
                                           |         | 
                                           |         |   gen_shape_v2('a') is not compatible with gen_shape('a')
                                           |         |   because
                                           |         |   #S{item_v2 := 'a' | gen_shape_v2('a')} is not compatible with gen_shape('a')
                                           |         |   because
                                           |         |   #S{item_v2 := 'a' | gen_shape_v2('a')} is not compatible with #S{item := 'a' | gen_shape('a')}
                                           |         |   These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    item    := ...
                                           |         | +    item_v2 := ...
                                           |         |   }
                                           |         |
-spec extra_1_neg(                         |         |
    #{a => va, b => vb, c => vc, d => vd}  |         |
) ->                                       |         |
    #{a => va, b => vb, c => vc}.          |         |
extra_1_neg(X) ->                          | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   #S{a => 'va', b => 'vb', c => 'vc', d => 'vd'}
                                           |         | Context expected type: #S{a => 'va', b => 'vb', c => 'vc'}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    d => ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec extra_2_neg(                         |         |
    #{                                     |         |
        a => va,                           |         |
        b => vb,                           |         |
        c => vc,                           |         |
        d => vd,                           |         |
        e => ve                            |         |
    }                                      |         |
) ->                                       |         |
    #{a => ka, b => kb, c => kc}.          |         |
extra_2_neg(X) ->                          | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   #S{a => 'va', b => 'vb', c => 'vc', d => 'vd', e => 've'}
                                           |         | Context expected type: #S{a => 'ka', b => 'kb', c => 'kc'}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    d => ...
                                           |         | +    e => ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec missing_1_neg(                       |         |
    #{a := va}                             |         |
) ->                                       |         |
    #{a := va}.                            |         |
missing_1_neg(X) ->                        | OK      |
    X.                                     |         |
                                           |         |
-spec missing_2_neg(                       |         |
    #{ }                                   |         |
) ->                                       |         |
    #{a => va, b => vb, c := vc}.          |         |
missing_2_neg(X) ->                        | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   #S{}
                                           |         | Context expected type: #S{a => 'va', b => 'vb', c := 'vc'}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    c := ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec expected_required_got_opt_1_neg(     |         |
    #{a => ka, b => kb, c => kc}           |         |
) ->                                       |         |
    #{a => ka, b := kb, c => kc}.          |         |
expected_required_got_opt_1_neg(X) ->      | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   #S{a => 'ka', b => 'kb', c => 'kc'}
                                           |         | Context expected type: #S{a => 'ka', b := 'kb', c => 'kc'}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    b := ...
                                           |         | +    b => ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec expected_required_got_opt_2_neg(     |         |
    #{a => ka, b => kb, c => kc}           |         |
) ->                                       |         |
    #{a => ka, b := kb, c => kc}.          |         |
expected_required_got_opt_2_neg(X) ->      | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   #S{a => 'ka', b => 'kb', c => 'kc'}
                                           |         | Context expected type: #S{a => 'ka', b := 'kb', c => 'kc'}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    b := ...
                                           |         | +    b => ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec misc_mismatch_1_neg(                 |         |
   #{                                      |         |
       k_ok => term(),                     |         |
       k_wrong1 => pid(),                  |         |
       k_wrong2 => pid(),                  |         |
       k_req1 => term(),                   |         |
       k_req2 => term(),                   |         |
       k_extra => term()                   |         |
   }                                       |         |
) ->                                       |         |
    #{                                     |         |
        k_ok => term(),                    |         |
        k_wrong1 => atom(),                |         |
        k_wrong2 => atom(),                |         |
        k_req1 := atom(),                  |         |
        k_req2 := atom(),                  |         |
        k_req3 := atom()                   |         |
    }.                                     |         |
misc_mismatch_1_neg(X) ->                  | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   #S{k_extra => term(), k_ok => term(), k_req1 => term(), k_req2 => term(), k_wrong1 => pid(), k_wrong2 => pid()}
                                           |         | Context expected type: #S{k_ok => term(), k_req1 := atom(), k_req2 := atom(), k_req3 := atom(), k_wrong1 => atom(), k_wrong2 => atom()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    k_extra  => ...
                                           |         | -    k_req1   := ...
                                           |         | +    k_req1   => ...
                                           |         | -    k_req2   := ...
                                           |         | +    k_req2   => ...
                                           |         | -    k_req3   := ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec map_k_pattern(                       |         |
    #{term() => atom()}                    |         |
) -> atom().                               |         |
map_k_pattern(                             | OK      |
    #{#{key => val} := I}                  |         |
) -> I.                                    |         |
                                           |         |
-spec dict_to_shape_1(                     |         |
    #{a | b => boolean()}                  |         |
) -> #{a => boolean(), b => term()}.       |         |
dict_to_shape_1(M) -> M.                   | OK      |
                                           |         |
-spec dict_to_shape_2(                     |         |
    #{a | b => boolean()}                  |         |
) -> #{a => boolean(), b => term(), c => b……         |
dict_to_shape_2(M) -> M.                   | OK      |
                                           |         |
-spec dict_to_shape_neg_1(                 |         |
    #{a | b => boolean()}                  |         |
) -> #{a => true, b => boolean()}.         |         |
dict_to_shape_neg_1(M) -> M.               | ERROR   | M.
                                           |         | Expression has type:   dict  map #D{'a' | 'b' => boolean()}
                                           |         | Context expected type: shape map #S{a => 'true', b => boolean()}
                                           |         |
-spec dict_to_shape_neg_2(                 |         |
    #{a | b => boolean()}                  |         |
) -> #{a => boolean(), b := term()}.       |         |
dict_to_shape_neg_2(M) -> M.               | ERROR   | M.
                                           |         | Expression has type:   dict  map #D{'a' | 'b' => boolean()}
                                           |         | Context expected type: shape map #S{a => boolean(), b := term()}
                                           |         |
-spec dict_to_shape_neg_3(                 |         |
    #{a | b => boolean()}                  |         |
) -> #{a => boolean()}.                    |         |
dict_to_shape_neg_3(M) -> M.               | ERROR   | M.
                                           |         | Expression has type:   dict  map #D{'a' | 'b' => boolean()}
                                           |         | Context expected type: shape map #S{a => boolean()}
