%%% Copyright (c) Meta Platforms, Inc. and……         |
%%%                                        |         |
%%% This source code is licensed under the……         |
%%% the LICENSE file in the root directory……         |
                                           |         |
-module(generic_fun_application).          |         |
-compile([export_all, nowarn_export_all]). |         |
                                           |         |
% References to Gradualizer are            |         |
% github.com/josefs/Gradualizer            |         |
% c83a9b49e2c43d7a63                       |         |
                                           |         |
% References to TypeScript are v4.1.5.     |         |
% See adapted examples playground:         |         |
% https://fburl.com/1dg2xiyb               |         |
                                           |         |
% References to "TRacket"                  |         |
% are Racket 7.8: #lang typed/racket       |         |
% Adapted examples paste:                  |         |
% https://fburl.com/phabricator/4uygbfg7   |         |
                                           |         |
-spec test00_pos() -> number().            |         |
test00_pos() -> fapply(fun id_num/1, 1).   | OK      |
                                           |         |
% gradualizer (unsound) accepts this       |         |
-spec test01_neg(atom()) -> pid().         |         |
test01_neg(X) -> fapply(fun id/1, X).      | ERROR   | fapply(id/1, X).
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: pid()
                                           |         |
% TRacket rejects this, msg is interesting |         |
% TypeScript (expressive) accepts this     |         |
% Gradualizer (expressive) accepts this    |         |
-spec test02() -> number().                |         |
test02() -> fapply(fun id/1, 1).           | OK      |
                                           |         |
% `lmap/2` is data-last                    |         |
-spec test03_neg() -> ok.                  |         |
test03_neg() ->                            | ERROR   |
    lmap(fun atom_to_pid/1, [2, 4]).       |         | [2, 4].
                                           |         | Expression has type:   [number()]
                                           |         | Context expected type: [atom()]
                                           |         | 
                                           |         |   [number()] is not compatible with [atom()]
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
% `mapl/2` is data-first                   |         |
-spec test03b_neg() -> ok.                 |         |
test03b_neg() ->                           | ERROR   |
    mapl([2, 4], fun atom_to_pid/1).       |         | atom_to_pid/1.
                                           |         | Expression has type:   fun((atom()) -> pid())
                                           |         | Context expected type: fun((number()) -> B)
                                           |         | 
                                           |         |   fun((atom()) -> pid()) is not compatible with fun((number()) -> B)
                                           |         |   because
                                           |         |   pid() is not compatible with B
                                           |         |
-spec test04_neg() -> ok.                  |         |
test04_neg() ->                            | ERROR   |
    X = lmap(fun atom_to_pid/1, [2, 4]),   |         | [2, 4].
                                           |         | Expression has type:   [number()]
                                           |         | Context expected type: [atom()]
                                           |         | 
                                           |         |   [number()] is not compatible with [atom()]
                                           |         |   because
                                           |         |   number() is not compatible with atom()
    X.                                     |         |
                                           |         |
-spec test04b_neg() -> ok.                 |         |
test04b_neg() ->                           | ERROR   |
    X = mapl([2, 4], fun atom_to_pid/1),   |         | atom_to_pid/1.
                                           |         | Expression has type:   fun((atom()) -> pid())
                                           |         | Context expected type: fun((number()) -> B)
                                           |         | 
                                           |         |   fun((atom()) -> pid()) is not compatible with fun((number()) -> B)
                                           |         |   because
                                           |         |   pid() is not compatible with B
    X.                                     |         |
                                           |         |
-spec test05_pos(atom()) -> atom().        |         |
test05_pos(X) -> id(X).                    | OK      |
                                           |         |
-spec test06_pos() -> {v2, v3, v1}.        |         |
test06_pos() ->                            | OK      |
    tuple3_rotate({v1, v2, v3}).           |         |
                                           |         |
-spec test07_pos() -> h.                   |         |
test07_pos() ->                            | OK      |
    lhead([h]).                            |         |
                                           |         |
-spec test08_neg() -> h.                   |         |
test08_neg() -> lhead(h).                  | ERROR   | 'h'.
                                           |         | Expression has type:   'h'
                                           |         | Context expected type: [LH]
                                           |         |
-spec maptt(#{T => T}) -> T.               |         |
maptt(_) -> throw(not_implemented).        | OK      |
                                           |         |
-spec test08_pos(                          |         |
    #{number() => number()}                |         |
) -> number().                             |         |
test08_pos(M) -> maptt(M).                 | OK      |
                                           |         |
-spec test09_neg(                          |         |
    #{number() => number()}                |         |
) -> pid().                                |         |
test09_neg(M) -> maptt(M).                 | ERROR   | maptt(M).
                                           |         | Expression has type:   number()
                                           |         | Context expected type: pid()
                                           |         |
-spec map_att(#{a => T}) -> T.             |         |
map_att(M) -> maps:get(a, M).              | OK      |
                                           |         |
-spec test10_pos(                          |         |
    #{a => pid()}                          |         |
) -> pid().                                |         |
test10_pos(M) ->                           | OK      |
    map_att(M).                            |         |
                                           |         |
-spec test11_neg(                          |         |
    #{true => pid()}                       |         |
) -> pid().                                |         |
test11_neg(M) ->                           | ERROR   |
    map_att(M).                            |         | M.
                                           |         | Expression has type:   #S{true => pid()}
                                           |         | Context expected type: #S{a => T}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    true => ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec test12_neg() -> pid().               |         |
test12_neg() ->                            | ERROR   |
    map_att(3).                            |         | 3.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: #S{a => T}
                                           |         |
-spec test13_neg() -> ok.                  |         |
test13_neg() -> lmap({}, [2, 4]).          | ERROR   | {}.
                                           |         | Expression has type:   {}
                                           |         | Context expected type: fun((A) -> B)
                                           |         |
-spec test13b_neg() -> ok.                 |         |
test13b_neg() -> mapl([2, 4], {}).         | ERROR   | {}.
                                           |         | Expression has type:   {}
                                           |         | Context expected type: fun((number()) -> B)
                                           |         |
-spec test14_pos(                          |         |
    #{a => number()}                       |         |
) -> number().                             |         |
test14_pos(Shape) ->                       | OK      |
    map_att(Shape).                        |         |
                                           |         |
% gradualizer (unsound) accepts this       |         |
-spec test15_neg(                          |         |
    fun((#{atom() => T}) -> T),            |         |
    #{a => number()}                       |         |
) -> pid().                                |         |
test15_neg(F, Shape) ->                    | ERROR   |
    F(Shape).                              |         | Shape.
                                           |         | Expression has type:   #S{a => number()}
                                           |         | Context expected type: #D{atom() => T}
                                           |         | 
                                           |         |   #S{a => number()} is not compatible with #D{atom() => T}
                                           |         |   because
                                           |         |   number() is not compatible with T
                                           |         |
-spec test16_neg(                          |         |
    fun(({X}) -> X),                       |         |
    tuple()                                |         |
) -> false.                                |         |
test16_neg(F, Tuple) ->                    | ERROR   |
    F(Tuple).                              |         | Tuple.
                                           |         | Expression has type:   tuple()
                                           |         | Context expected type: {X}
                                           |         |
-spec test17_neg(fun()) -> ok.             |         |
test17_neg(F) ->                           | ERROR   |
    lmap(F, [2, 4]).                       |         | F.
                                           |         | Expression has type:   fun()
                                           |         | Context expected type: fun((A) -> B)
                                           |         |
-spec test17b_neg(fun()) -> ok.            |         |
test17b_neg(F) ->                          | ERROR   |
    mapl([2, 4], F).                       |         | F.
                                           |         | Expression has type:   fun()
                                           |         | Context expected type: fun((number()) -> B)
                                           |         |
-type kv(K, V) :: #{K => V}.               |         |
                                           |         |
-spec test18_pos(K, V) -> kv(K, V).        |         |
test18_pos(K, V) ->                        | OK      |
    #{K => V}.                             |         |
                                           |         |
-spec test19_neg(a | b) -> a.              |         |
test19_neg(AB) ->                          | ERROR   |
    ttt(AB, a).                            |         | ttt(AB, 'a').
                                           |         | Expression has type:   'a' | 'b'
                                           |         | Context expected type: 'a'
                                           |         | 
                                           |         |   'a' | 'b' is not compatible with 'a'
                                           |         |   because
                                           |         |   'b' is not compatible with 'a'
                                           |         |
% Gradualizer accepts this                 |         |
% TypesScript rejects this                 |         |
% TRacket requires annotations for `let`   |         |
-spec test20_pos() -> a | b.               |         |
test20_pos() ->                            | OK      |
    X = ttt(a, b),                         |         |
    X.                                     |         |
                                           |         |
% Gradualizer (unsound) accepts this       |         |
-spec test21_neg() -> pid().               |         |
test21_neg() ->                            | ERROR   |
    ttt(a, b).                             |         | ttt('a', 'b').
                                           |         | Expression has type:   'a' | 'b'
                                           |         | Context expected type: pid()
                                           |         |
% All checkers tested accept this          |         |
-spec test22_pos() -> a | b.               |         |
test22_pos() ->                            | OK      |
    ttt(a, b).                             |         |
                                           |         |
% Gradualizer (unsound) accepts this       |         |
-spec test23_neg() -> a.                   |         |
test23_neg() ->                            | ERROR   |
    ttt(a, b).                             |         | ttt('a', 'b').
                                           |         | Expression has type:   'a' | 'b'
                                           |         | Context expected type: 'a'
                                           |         | 
                                           |         |   'a' | 'b' is not compatible with 'a'
                                           |         |   because
                                           |         |   'b' is not compatible with 'a'
                                           |         |
% Gradualizer (unsound) accepts this       |         |
-spec test24_neg() -> b.                   |         |
test24_neg() ->                            | ERROR   |
    ttt(a, b).                             |         | ttt('a', 'b').
                                           |         | Expression has type:   'a' | 'b'
                                           |         | Context expected type: 'b'
                                           |         | 
                                           |         |   'a' | 'b' is not compatible with 'b'
                                           |         |   because
                                           |         |   'a' is not compatible with 'b'
                                           |         |
-spec test25_pos() -> term().              |         |
test25_pos() ->                            | OK      |
    l_item([2, a], b).                     |         |
                                           |         |
-spec test25b_pos() -> term().             |         |
test25b_pos() ->                           | OK      |
    item_l(b, [2, a]).                     |         |
                                           |         |
-spec test26_pos() -> term().              |         |
test26_pos() ->                            | OK      |
    l_item([2, a], a).                     |         |
                                           |         |
-spec test26b_pos() -> term().             |         |
test26b_pos() ->                           | OK      |
    item_l(a, [2, a]).                     |         |
                                           |         |
-spec test27_pos(                          |         |
    #{a => number()},                      |         |
    #{atom() => number()}                  |         |
) -> #{atom() => number()}.                |         |
test27_pos(Shape, Dict) ->                 | OK      |
    X = ttt(Shape, Dict),                  |         |
    X.                                     |         |
                                           |         |
-spec test28_pos(                          |         |
    #{atom() => number()},                 |         |
    #{a => number()}                       |         |
) -> #{atom() => number()}.                |         |
test28_pos(Dict, Shape) ->                 | OK      |
    X = ttt(Dict, Shape),                  |         |
    X.                                     |         |
                                           |         |
-spec test29_pos(                          |         |
    {#{atom() => number()}},               |         |
    {#{a => number()}}                     |         |
) -> {#{atom() => number()}}.              |         |
test29_pos(DictTup, ShapeTup) ->           | OK      |
    X = ttt(DictTup, ShapeTup),            |         |
    X.                                     |         |
                                           |         |
-spec test30_neg(                          |         |
    {#{a => number()}},                    |         |
    {#{atom() => number()}}                |         |
) -> {#{atom() => number()}}.              |         |
test30_neg(ShapeTup, DictTup) ->           | OK      |
    X = ttt(ShapeTup, DictTup),            |         |
    X.                                     |         |
                                           |         |
-spec test31_pos(                          |         |
    term(),                                |         |
    none()                                 |         |
) -> term().                               |         |
test31_pos(Any, None) ->                   | OK      |
    X = ttt(Any, None),                    |         |
    X.                                     |         |
                                           |         |
-spec test32_pos(                          |         |
    term(),                                |         |
    pid()                                  |         |
) -> term().                               |         |
test32_pos(Any, Pid) ->                    | OK      |
    X = ttt(Any, Pid),                     |         |
    X.                                     |         |
                                           |         |
-spec test33_pos(                          |         |
    none(),                                |         |
    pid()                                  |         |
) -> term().                               |         |
test33_pos(None, Pid) ->                   | OK      |
    X = ttt(None, Pid),                    |         |
    X.                                     |         |
                                           |         |
-spec test34_pos(                          |         |
    none()                                 |         |
) -> [pid()].                              |         |
test34_pos(None) ->                        | OK      |
    X=lmap(fun atom_to_pid/1, [None, a]),  |         |
    X.                                     |         |
                                           |         |
-spec test35_pos() -> number().            |         |
test35_pos() ->                            | OK      |
    (id(fun id_num/1))(3).                 |         |
                                           |         |
-spec test36_neg(fun(({T}) -> U), T) -> U. |         |
test36_neg(F, X) -> F(X).                  | ERROR   | X.
                                           |         | Expression has type:   T
                                           |         | Context expected type: {T}
                                           |         |
-spec test38_pos(                          |         |
    fun((F) -> T),                         |         |
    F                                      |         |
) -> T when F :: fun((Z, {Z}, [Z]) -> Z).  |         |
test38_pos(FT, F) -> FT(F).                | OK      |
                                           |         |
-spec test39_neg                           |         |
    (fun(() -> A), A, X)                   |         |
    -> fun(() -> X).                       |         |
test39_neg(F, _, _) ->                     | ERROR   |
    fun0_id(F).                            |         | fun0_id(F).
                                           |         | Expression has type:   fun(() -> A)
                                           |         | Context expected type: fun(() -> X)
                                           |         | 
                                           |         |   fun(() -> A) is not compatible with fun(() -> X)
                                           |         |   because
                                           |         |   A is not compatible with X
                                           |         |
-spec test40_neg                           |         |
    (fun((A) -> B), {A, B},  {X, Y})       |         |
    -> fun((X) -> Y).                      |         |
test40_neg(F, _, _) ->                     | ERROR   |
    fun0_id(F).                            |         | F.
                                           |         | Expression has type:   fun((A) -> B)
                                           |         | Context expected type: fun(() -> X)
                                           |         |
-spec test41_neg() -> atom().              |         |
test41_neg() ->                            | OK      |
    (test39_neg(fun mk_number/0, 0, x))(). |         |
                                           |         |
-spec                                      |         |
last_shall_be_first_neg                    |         |
    (first, Last, Last) -> first.          |         |
last_shall_be_first_neg                    | ERROR   |
(First, Last, Last) ->                     |         |
    X = second_among_equals(First, Last),  |         |
    X.                                     |         | X.
                                           |         | Expression has type:   'first' | Last
                                           |         | Context expected type: 'first'
                                           |         | 
                                           |         |   'first' | Last is not compatible with 'first'
                                           |         |   because
                                           |         |   Last is not compatible with 'first'
                                           |         |
-spec                                      |         |
atoms_shall_be_anything_neg                |         |
    (atom(), T, T) -> atom().              |         |
atoms_shall_be_anything_neg                | ERROR   |
(Atom, Foo, _) ->                          |         |
    X = second_among_equals(Atom, Foo),    |         |
    X.                                     |         | X.
                                           |         | Expression has type:   atom() | T
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   atom() | T is not compatible with atom()
                                           |         |   because
                                           |         |   T is not compatible with atom()
                                           |         |
 -spec fun1_id_pos                         |         |
 (fun((A) -> B)) -> fun((A) -> B).         |         |
fun1_id_pos(F) -> id(F).                   | OK      |
                                           |         |
 -spec fun1_id_pos_a                       |         |
 (fun((A) -> A)) -> fun((A) -> A).         |         |
fun1_id_pos_a(F) -> id(F).                 | OK      |
                                           |         |
 -spec fun1_id_pos_z                       |         |
 (fun((Z) -> Z)) -> fun((Z) -> Z).         |         |
fun1_id_pos_z(F) -> id(F).                 | OK      |
                                           |         |
-spec shape_order_pos() ->                 |         |
    {pid(), number()}.                     |         |
shape_order_pos() ->                       | OK      |
    Pid = erlang:self(),                   |         |
    expect_shape(                          |         |
        #{u => 1, t => Pid}                |         |
    ).                                     |         |
                                           |         |
-spec shape_order_neg() ->                 |         |
    {pid(), number()}.                     |         |
shape_order_neg() ->                       | ERROR   |
    Pid = erlang:self(),                   |         |
    expect_shape(                          |         | expect_shape(#{..}).
                                           |         | Expression has type:   {number(), pid()}
                                           |         | Context expected type: {pid(), number()}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {number(), pid()} is not compatible with {pid(), number()}
                                           |         |   because
                                           |         |   number() is not compatible with pid()
        #{t => 1, u => Pid}                |         |
    ).                                     |         |
                                           |         |
-spec leak_c_neg                           |         |
    (fun((A) -> B), A, B, C)               |         |
    -> C.                                  |         |
leak_c_neg(F, A, _B, _C) ->                | ERROR   |
    F(A).                                  |         | F(A).
                                           |         | Expression has type:   B
                                           |         | Context expected type: C
                                           |         |
-spec exploit_leak_c_neg() -> expect_pid.  |         |
 exploit_leak_c_neg() ->                   | OK      |
    leak_c_neg(                            |         |
        fun atom_to_pid/1,                 |         |
        a,                                 |         |
        erlang:self(),                     |         |
        expect_pid).                       |         |
                                           |         |
% Could be supported in future.            |         |
-spec test_fun_doubler1() -> number().     |         |
test_fun_doubler1() ->                     | ERROR   |
    F = fun id/1,                          |         |
    G = fun_doubler(                       |         |
        F,                                 |         |
        fun fun1_id_pos_a/1),              |         | Arg 1 of 'fun1_id_pos_a/1'.
                                           |         | Expression has type:   fun((Z) -> Z) with 1 type parameter
                                           |         | Context expected type: fun((A) -> A) with 0 type parameters
    X = (G(G))(fun id/1),                  |         |
    X(1).                                  |         |
                                           |         |
% should type-check iff test_fun_doubler1  |         |
% type-checks. Only difference is          |         |
% type variable names in fun1_id_pos_X     |         |
-spec test_fun_doubler2() -> number().     |         |
test_fun_doubler2() ->                     | ERROR   |
    F = fun id/1,                          |         |
    G = fun_doubler(                       |         |
        F,                                 |         |
        fun fun1_id_pos_z/1),              |         | Arg 1 of 'fun1_id_pos_z/1'.
                                           |         | Expression has type:   fun((Z) -> Z) with 1 type parameter
                                           |         | Context expected type: fun((Z) -> Z) with 0 type parameters
    X = (G(G))(fun id/1),                  |         |
    X(1).                                  |         |
                                           |         |
% helpers                                  |         |
                                           |         |
-spec expect_shape (#{t := T, u := U}) ->  |         |
    {T, U}.                                |         |
expect_shape(#{t := T, u:= U}) ->          | OK      |
    {T, U}.                                |         |
                                           |         |
-spec item_l(T, [T]) -> T.                 |         |
item_l(X, _) -> X.                         | OK      |
                                           |         |
-spec l_item([T], T) -> T.                 |         |
l_item(_, X) -> X.                         | OK      |
                                           |         |
-spec ttt(T, T) -> T.                      |         |
ttt(X, _) -> X.                            | OK      |
                                           |         |
-spec second_among_equals                  |         |
    (A, A)  -> A.                          |         |
second_among_equals                        | OK      |
(_, A) -> A.                               |         |
                                           |         |
-spec atom_to_pid(atom()) -> pid().        |         |
atom_to_pid(_) -> erlang:self().           | OK      |
                                           |         |
-spec tuple3_rotate(                       |         |
    {TT1, TT2, TT3}) -> {TT2, TT3, TT1}.   |         |
tuple3_rotate({V1, V2, V3}) ->             | OK      |
    {V2, V3, V1}.                          |         |
                                           |         |
-spec lhead([LH]) -> LH.                   |         |
lhead([LH]) -> LH.                         | OK      |
                                           |         |
-spec id(Z) -> Z.                          |         |
id(Z) -> Z.                                | OK      |
                                           |         |
-spec id_num(number()) -> number().        |         |
id_num(X) -> X.                            | OK      |
                                           |         |
-spec fapply(fun((T) -> U), T) -> U.       |         |
fapply(F, X) ->                            | OK      |
    ZZ = F(X),                             |         |
    ZZ.                                    |         |
                                           |         |
-spec lmap(fun((A) -> B), [A]) -> [B].     |         |
lmap(_F, _XS) -> [].                       | OK      |
                                           |         |
-spec mapl([A], fun((A) -> B)) -> [B].     |         |
mapl(_XS, _F) -> [].                       | OK      |
                                           |         |
-spec fun0_id                              |         |
    (fun(() -> X)) -> fun(() -> X).        |         |
fun0_id(F) ->                              | OK      |
    F.                                     |         |
                                           |         |
-spec mk_number() -> number().             |         |
mk_number() -> 1.                          | OK      |
                                           |         |
-spec fun_doubler(T, fun((T) -> T)) ->     |         |
    fun((T) -> T).                         |         |
fun_doubler(_, X) -> X.                    | OK      |
                                           |         |
-spec num_and_t(number(), T) -> T.         |         |
num_and_t(_, X) -> X.                      | OK      |
                                           |         |
-spec shape_vars(#{a := T}, T)             |         |
    -> ok.                                 |         |
shape_vars(_, _) -> ok.                    | OK      |
                                           |         |
-spec test_dict1(#{atom() => pid()}) ->    |         |
    ok.                                    |         |
test_dict1(D) -> num_and_t(D, D).          | ERROR   | D.
                                           |         | Expression has type:   #D{atom() => pid()}
                                           |         | Context expected type: number()
                                           |         |
-spec dict_vars                            |         |
    (fun((#{{T} => T}) -> T), T)           |         |
    -> ok.                                 |         |
dict_vars(_, _) -> ok.                     | OK      |
                                           |         |
-spec test_dict2(T) -> T.                  |         |
test_dict2(T) ->                           | ERROR   |
    shape_vars(#{T => 3}, 3).              |         | #{..}.
                                           |         | Expression has type:   dict  map #D{T => number()}
                                           |         | Context expected type: shape map #S{a := T}
                                           |         |
-spec test_dict3                           |         |
    (fun((#{a => 1}) -> 1), 1) -> ok.      |         |
test_dict3(F, N) ->                        | ERROR   |
    dict_vars(F, N).                       |         | F.
                                           |         | Expression has type:   fun((#S{a => number()}) -> number())
                                           |         | Context expected type: fun((#D{{T} => T}) -> T)
                                           |         | 
                                           |         |   fun((#S{a => number()}) -> number()) is not compatible with fun((#D{{T} => T}) -> T)
                                           |         |   because
                                           |         |   number() is not compatible with T
                                           |         |
-spec atat(atom()) -> atom().              |         |
atat(X) -> X.                              | OK      |
                                           |         |
-type tup(X, Y) :: {X, Y}.                 |         |
                                           |         |
                                           |         |
                                           |         |
-spec idtup(tup(T, U)) -> tup(T, U).       |         |
idtup(X) -> id(X).                         | OK      |
                                           |         |
-spec test_idtup() -> {a, b}.              |         |
test_idtup() ->                            | OK      |
    X = idtup({a, b}),                     |         |
    X.                                     |         |
                                           |         |
-spec test_aliases_pos(                    |         |
    fun(({X, Y}) -> {X, Y})) ->            |         |
    fun((tup(X, Y)) -> tup(X, Y)).         |         |
test_aliases_pos(F) -> F.                  | OK      |
                                           |         |
-spec test_aliases_neg(                    |         |
     fun((a) -> b)                         |         |
) -> fun((a) -> c).                        |         |
test_aliases_neg(F) -> F.                  | ERROR   | F.
                                           |         | Expression has type:   fun(('a') -> 'b')
                                           |         | Context expected type: fun(('a') -> 'c')
                                           |         | 
                                           |         |   fun(('a') -> 'b') is not compatible with fun(('a') -> 'c')
                                           |         |   because
                                           |         |   'b' is not compatible with 'c'
                                           |         |
-spec takesShape1(#{a := T}) -> T.         |         |
takesShape1(#{a := X}) -> X.               | OK      |
                                           |         |
-spec shapes_neg() -> nok.                 |         |
shapes_neg() ->                            | ERROR   |
    takesShape1(#{}).                      |         | #{..}.
                                           |         | Expression has type:   #S{}
                                           |         | Context expected type: #S{a := T}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    a := ...
                                           |         |   }
                                           |         |
-spec one() -> 1.                          |         |
one() -> 1.                                | OK      |
                                           |         |
-spec to_from(T) ->                        |         |
    fun((T) -> b).                         |         |
to_from(_) -> throw(not_implemented).      | OK      |
                                           |         |
-spec test_to_from_pos() -> fun((a) -> b). |         |
test_to_from_pos() ->                      | OK      |
    to_from(a).                            |         |
                                           |         |
-spec test_to_from_neg() ->                |         |
    fun((term()) -> b).                    |         |
test_to_from_neg() ->                      | OK      |
    to_from(a).                            |         |
                                           |         |
-spec test_quanitifer_scope_neg(           |         |
    fun((T) -> T),                         |         |
    number()                               |         |
) -> number().                             |         |
test_quanitifer_scope_neg(F, X) -> F(X).   | ERROR   | X.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: T
                                           |         |
-spec val_ty(                              |         |
    #{number() => T}                       |         |
) -> T.                                    |         |
val_ty(#{3 := T}) -> T.                    | OK      |
                                           |         |
-spec test_dict_ty() -> ok.                |         |
test_dict_ty() ->                          | OK      |
    val_ty(#{3 => ok}).                    |         |
                                           |         |
-spec tuplify(T) -> {T, T}.                |         |
tuplify(T) -> {T, T}.                      | OK      |
                                           |         |
-spec test_tuplify() -> {ok, ok}.          |         |
test_tuplify() ->                          | OK      |
    X = tuplify(ok),                       |         |
    X.                                     |         |
                                           |         |
-spec contravariant(T) -> fun((T) -> ok).  |         |
contravariant(_) ->                        | OK      |
    throw(not_implemented).                |         |
                                           |         |
-type invar(T) :: fun((T) -> T).           |         |
-type contravar(T) :: fun((T) -> ok).      |         |
                                           |         |
-spec invariant(T) -> invar(T).            |         |
invariant(_) -> throw(not_implemented).    | OK      |
                                           |         |
-spec test_contravariant_1() ->            |         |
    fun((term()) -> ok).                   |         |
test_contravariant_1() ->                  | OK      |
    X = contravariant(3),                  |         |
    X.                                     |         |
                                           |         |
-spec test_contravariant_2() ->            |         |
    fun((number() | pid()) -> ok).         |         |
test_contravariant_2() ->                  | OK      |
    X = contravariant(3),                  |         |
    X.                                     |         |
                                           |         |
-spec test_contravariant_3(                |         |
    contravar(a | b)                       |         |
) -> contravar(a).                         |         |
test_contravariant_3(X) ->                 | OK      |
    X.                                     |         |
                                           |         |
-spec test_contravariant_4_neg(            |         |
    contravar(contravar(a | b))            |         |
) -> contravar(contravar(a)).              |         |
test_contravariant_4_neg(X) ->             | ERROR   |
    X.                                     |         | X.
                                           |         | Expression has type:   contravar(contravar('a' | 'b'))
                                           |         | Context expected type: contravar(contravar('a'))
                                           |         | 
                                           |         |   contravar(contravar('a' | 'b')) is not compatible with contravar(contravar('a'))
                                           |         |   because
                                           |         |   fun((contravar('a' | 'b')) -> 'ok') is not compatible with contravar(contravar('a'))
                                           |         |   because
                                           |         |   fun((contravar('a' | 'b')) -> 'ok') is not compatible with fun((contravar('a')) -> 'ok')
                                           |         |   because
                                           |         |   contravar('a') is not compatible with contravar('a' | 'b')
                                           |         |
-spec test_contravariant_5(                |         |
    contravar(contravar(a))                |         |
) -> contravar(contravar(a | b)).          |         |
test_contravariant_5(X) ->                 | OK      |
    X.                                     |         |
                                           |         |
-spec test_invariant_neg() ->              |         |
    fun((atom()) -> atom()).               |         |
test_invariant_neg() ->                    | ERROR   |
    X = invariant(a),                      |         |
    X.                                     |         | X.
                                           |         | Expression has type:   invar('a')
                                           |         | Context expected type: fun((atom()) -> atom())
                                           |         | 
                                           |         |   invar('a') is not compatible with fun((atom()) -> atom())
                                           |         |   because
                                           |         |   fun(('a') -> 'a') is not compatible with fun((atom()) -> atom())
                                           |         |   because
                                           |         |   atom() is not compatible with 'a'
                                           |         |
-spec test_invariant_neg_2() ->            |         |
    invar(atom()).                         |         |
test_invariant_neg_2() ->                  | ERROR   |
    X = invariant(a),                      |         |
    X.                                     |         | X.
                                           |         | Expression has type:   invar('a')
                                           |         | Context expected type: invar(atom())
                                           |         | 
                                           |         |   invar('a') is not compatible with invar(atom())
                                           |         |   because
                                           |         |   fun(('a') -> 'a') is not compatible with invar(atom())
                                           |         |   because
                                           |         |   fun(('a') -> 'a') is not compatible with fun((atom()) -> atom())
                                           |         |   because
                                           |         |   atom() is not compatible with 'a'
                                           |         |
-spec test_invariant_pos_1(term()) ->      |         |
    fun((term()) -> term()).               |         |
test_invariant_pos_1(Any) ->               | OK      |
    X = invariant(Any),                    |         |
    X.                                     |         |
                                           |         |
-spec test_invariant_pos_2() ->            |         |
    fun((a) -> a).                         |         |
test_invariant_pos_2() ->                  | OK      |
    invariant(a).                          |         |
                                           |         |
-spec test_invariant_pos_3() ->            |         |
    invar(a).                              |         |
test_invariant_pos_3() ->                  | ERROR   |
    a.                                     |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: invar('a')
                                           |         | 
                                           |         |   'a' is not compatible with invar('a')
                                           |         |   because
                                           |         |   'a' is not compatible with fun(('a') -> 'a')
                                           |         |
-spec arg_eqv(                             |         |
    fun((T) -> pid()),                     |         |
    fun((T) -> pid())                      |         |
) -> T.                                    |         |
arg_eqv(_, _) -> throw(not_implemented).   | OK      |
                                           |         |
-spec num_to_pid(number()) -> pid().       |         |
num_to_pid(_) -> erlang:self().            | OK      |
                                           |         |
-spec any_to_pid(term()) -> pid().         |         |
any_to_pid(_) -> erlang:self().            | OK      |
                                           |         |
-spec meets_1() -> anything.               |         |
meets_1() ->                               | OK      |
    X = arg_eqv(                           |         |
        fun num_to_pid/1,                  |         |
        fun atom_to_pid/1),                |         |
    X.                                     |         |
                                           |         |
-spec meets_2() -> term().                 |         |
meets_2() ->                               | OK      |
    X = arg_eqv(                           |         |
        fun any_to_pid/1,                  |         |
        fun num_to_pid/1),                 |         |
    X.                                     |         |
                                           |         |
-spec meets_3() -> term().                 |         |
meets_3() ->                               | OK      |
    arg_eqv(                               |         |
        fun num_to_pid/1,                  |         |
        fun any_to_pid/1).                 |         |
                                           |         |
-spec stuff_1([                            |         |
    {a, #{f => a, ff := a}}                |         |
    | fun((a) -> b)                        |         |
    | #{{} => 3}]                          |         |
    | #{a => a}) ->                        |         |
        pid().                             |         |
stuff_1(0) -> erlang:self().               | OK      |
                                           |         |
-spec stuff_2([                            |         |
    {c, #{f => a, ff := b}}                |         |
    | fun((b) -> d)                        |         |
    | #{{} => {}}]                         |         |
    | #{b => b}) ->                        |         |
        pid().                             |         |
stuff_2(0) -> erlang:self().               | OK      |
                                           |         |
-spec meets_4() -> ok.                     |         |
meets_4() ->                               | OK      |
    X = arg_eqv(                           |         |
        fun stuff_1/1,                     |         |
        fun stuff_2/1),                    |         |
    X.                                     |         |
                                           |         |
-spec arity_check_1() -> nok.              |         |
arity_check_1() ->                         | ERROR   |
    F = fun id/1,                          |         |
    F(1, 2),                               |         | F.
                                           |         | Expected fun type with arity 2
                                           |         | Got: fun((Z) -> Z)
    nok.                                   |         |
                                           |         |
-spec arity_check_2() -> number().         |         |
arity_check_2() ->                         | ERROR   |
    F = fun id/1,                          |         |
    F(1, 2).                               |         | F.
                                           |         | Expected fun type with arity 2
                                           |         | Got: fun((Z) -> Z)
                                           |         |
-spec funify(A) -> fun((A) -> A).          |         |
funify(_) -> erlang:error(no_lambdas).     | OK      |
                                           |         |
-spec test_funify(                         |         |
    fun((number()) -> number()))           |         |
    -> term().                             |         |
test_funify(F) ->                          | OK      |
    Res = funify(F),                       |         |
    Res.                                   |         |
                                           |         |
-spec to_shape(T) -> #{a := T, b => T}.    |         |
to_shape(X) -> #{a => X, b => X}.          | OK      |
                                           |         |
-spec test_to_shape() ->                   |         |
    #{a := number(), b => number()}.       |         |
test_to_shape() ->                         | OK      |
    X = to_shape(1),                       |         |
    X.                                     |         |
                                           |         |
-spec map_t_t_t(#{T => T}) -> T.           |         |
map_t_t_t(_) -> throw(not_implemented).    | OK      |
                                           |         |
-spec test_shape_as_dict() -> a.           |         |
test_shape_as_dict() ->                    | OK      |
    map_t_t_t(#{a => a}).                  |         |
                                           |         |
-spec shape_width_neg() ->                 |         |
    {pid(), number()}.                     |         |
shape_width_neg() ->                       | ERROR   |
    Pid = erlang:self(),                   |         |
    expect_shape(                          |         |
        #{u => 1, t => Pid, extra => 3}    |         | #{..}.
                                           |         | Expression has type:   #S{extra := number(), t := pid(), u := number()}
                                           |         | Context expected type: #S{t := T, u := U}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    extra := ...
                                           |         |      ...
                                           |         |   }
    ).                                     |         |
                                           |         |
-spec expect_shape_opt(                    |         |
    #{t => T, u => U}                      |         |
) -> {T, U} | undefined.                   |         |
expect_shape_opt(#{t := T, u:= U}) ->      | OK      |
    {T, U};                                |         |
expect_shape_opt(_) ->                     |         |
    undefined.                             |         |
                                           |         |
-spec shape_width_pos() ->                 |         |
    {pid(), number()} | undefined.         |         |
shape_width_pos() ->                       | OK      |
    Pid = erlang:self(),                   |         |
    expect_shape_opt(                      |         |
        #{t => Pid}                        |         |
    ).                                     |         |
                                           |         |
-spec test_hygiene_pos([Elem], [Elem])     |         |
        -> [Elem].                         |         |
test_hygiene_pos(_, List) ->               | OK      |
    % regression test:                     |         |
    % funcs without ty vars should not     |         |
    % reset the var counter to 0           |         |
    _ = length(List),                      |         |
    _ = length(List),                      |         |
    lists:split(0, List),                  |         |
    List.                                  |         |
                                           |         |
-spec tat(T, a) -> T.                      |         |
tat(X, a) -> X.                            | OK      |
                                           |         |
-spec apply2(fun((T, U) -> T), T, U) -> T. |         |
apply2(F, X, Y) -> F(X, Y).                | OK      |
                                           |         |
-spec test_apply2() -> number().           |         |
test_apply2() -> apply2(fun tat/2, 1, 1).  | ERROR   | Arg 2 of 'tat/2'.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: 'a'
                                           |         |
-spec invar(T, T) -> fun((T) -> T).        |         |
invar(_T, U) ->                            | OK      |
    fun(_X) -> U end.                      |         |
                                           |         |
-spec test_invar1() -> fun((a) -> a).      |         |
test_invar1() ->                           | OK      |
    invar(a, a).                           |         |
                                           |         |
-spec test_invar2(a | b) ->                |         |
    fun((a | b) -> a | b).                 |         |
test_invar2(AB) ->                         | OK      |
    invar(a, AB).                          |         |
                                           |         |
-spec test_invar3_neg() ->                 |         |
    fun((a | b) -> a | b).                 |         |
test_invar3_neg() ->                       | ERROR   |
    invar(a, a).                           |         | invar('a', 'a').
                                           |         | Expression has type:   fun(('a') -> 'a')
                                           |         | Context expected type: fun(('a' | 'b') -> 'a' | 'b')
                                           |         | 
                                           |         |   fun(('a') -> 'a') is not compatible with fun(('a' | 'b') -> 'a' | 'b')
                                           |         |   because
                                           |         |   'a' | 'b' is not compatible with 'a'
                                           |         |   because
                                           |         |   'b' is not compatible with 'a'
                                           |         |
-spec fun_with_tuple                       |         |
    (tuple(), [A]) -> {tuple(), [A]}.      |         |
fun_with_tuple(T, L) -> {T, L}.            | OK      |
                                           |         |
-spec use_fun_with_tuple_1() -> ok.        |         |
use_fun_with_tuple_1() ->                  | OK      |
    _ = fun_with_tuple({a, b}, []),        |         |
    ok.                                    |         |
                                           |         |
-spec use_fun_with_tuple_2_neg() -> ok.    |         |
use_fun_with_tuple_2_neg() ->              | ERROR   |
    _ = fun_with_tuple({a, b}, {}),        |         | {}.
                                           |         | Expression has type:   {}
                                           |         | Context expected type: [A]
    ok.                                    |         |
