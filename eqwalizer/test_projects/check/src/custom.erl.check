%%% Copyright (c) Meta Platforms, Inc. and……         |
%%%                                        |         |
%%% This source code is licensed under the……         |
%%% the LICENSE file in the root directory……         |
                                           |         |
-module(custom).                           |         |
                                           |         |
-import(maps, [get/2, get/3]).             |         |
-compile([export_all, nowarn_export_all]). |         |
                                           |         |
-record(foo, {                             |         |
    a :: ok | error,                       |         |
    b :: number(),                         |         |
    c :: string()                          |         |
}).                                        |         |
                                           |         |
% element/2 - basic examples               |         |
                                           |         |
-spec element_2_basic_1({atom(), number(),……         |
element_2_basic_1(Tup) ->                  | OK      |
    element(1, Tup).                       |         |
                                           |         |
-spec element_2_basic_2_neg({atom(), numbe……         |
element_2_basic_2_neg(Tup) ->              | ERROR   |
    element(4, Tup).                       |         | erlang:element(4, Tup).
                                           |         | Expression has type:   #D{eqwalizer:dynamic() => eqwalizer:dynamic()}
                                           |         | Context expected type: atom()
                                           |         |
-spec element_2_basic_3_neg({atom(), numbe……         |
element_2_basic_3_neg(Tup) ->              | ERROR   |
    element(42, Tup).                      |         | 42.
                                           |         | Tried to access element 42 of a tuple with 3 elements
                                           |         |
% element/2 - union examples               |         |
                                           |         |
-spec element_2_union_1({atom(), number() ……         |
element_2_union_1(Tup) ->                  | OK      |
    element(2, Tup).                       |         |
                                           |         |
-spec element_2_union_2_neg({atom(), numbe……         |
element_2_union_2_neg(Tup) ->              | ERROR   |
    element(2, Tup).                       |         | erlang:element(2, Tup).
                                           |         | Expression has type:   number() | string() | atom()
                                           |         | Context expected type: #D{eqwalizer:dynamic() => eqwalizer:dynamic()}
                                           |         |
-spec element_2_union_3_neg({atom(), strin……         |
element_2_union_3_neg(Tup) ->              | ERROR   |
    element(2, Tup).                       |         | Tup.
                                           |         | Expression has type:   {atom(), string()} | [eqwalizer:dynamic()]
                                           |         | Context expected type: tuple()
                                           |         | 
                                           |         |   {atom(), string()} | [eqwalizer:dynamic()] is not compatible with tuple()
                                           |         |   because
                                           |         |   [eqwalizer:dynamic()] is not compatible with tuple()
                                           |         |
-spec element_2_union_4_neg({c, d, e, f} |……         |
element_2_union_4_neg(Tup) ->              | ERROR   |
    element(42, Tup).                      |         | 42.
                                           |         | Tried to access element 42 of a tuple with 2 elements
                                           |         |
% element/2 - dynamic index examples       |         |
                                           |         |
-spec element_2_dynindex_1_neg(pos_integer……         |
element_2_dynindex_1_neg(N, Tup) ->        | ERROR   |
    element(N, Tup).                       |         | erlang:element(N, Tup).
                                           |         | Expression has type:   atom() | number() | string()
                                           |         | Context expected type: #D{eqwalizer:dynamic() => eqwalizer:dynamic()}
                                           |         |
-spec element_2_dynindex_2_neg(pos_integer……         |
element_2_dynindex_2_neg(N, Tup) ->        | ERROR   |
    element(N, Tup).                       |         | erlang:element(N, Tup).
                                           |         | Expression has type:   atom() | number()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   atom() | number() is not compatible with atom()
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
% element/2 - tuple() examples             |         |
                                           |         |
-spec element_2_anytuple_1_neg(tuple()) ->……         |
element_2_anytuple_1_neg(Tup) ->           | ERROR   |
    element(1, Tup).                       |         | erlang:element(1, Tup).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: atom()
                                           |         |
-spec element_2_anytuple_2_neg(tuple() | {……         |
element_2_anytuple_2_neg(Tup) ->           | ERROR   |
    element(1, Tup).                       |         | erlang:element(1, Tup).
                                           |         | Expression has type:   term() | number()
                                           |         | Context expected type: atom()
                                           |         |
% element/2 - record examples              |         |
                                           |         |
-spec element_2_record_1(#foo{}) -> foo.   |         |
element_2_record_1(Rec) ->                 | OK      |
    element(1, Rec).                       |         |
                                           |         |
-spec element_2_record_2(#foo{}) -> ok | e……         |
element_2_record_2(Rec) ->                 | OK      |
    element(2, Rec).                       |         |
                                           |         |
-spec element_2_record_3(#foo{}) -> ok.    |         |
element_2_record_3(Rec) when Rec#foo.a =/=…… OK      |
    element(2, Rec).                       |         |
                                           |         |
-spec element_2_record_4_neg(pos_integer()……         |
element_2_record_4_neg(N, Rec) ->          | ERROR   |
    element(N, Rec).                       |         | erlang:element(N, Rec).
                                           |         | Expression has type:   'foo' | 'ok' | 'error' | number() | string()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   'foo' | 'ok' | 'error' | number() | string() is not compatible with atom()
                                           |         |   because
                                           |         |   string() is not compatible with atom()
                                           |         |
% element/2 - none examples                |         |
                                           |         |
-spec element_2_none_1(none()) -> number()……         |
element_2_none_1(Tup) ->                   | OK      |
    element(42, Tup).                      |         |
                                           |         |
-spec element_2_none_2(pos_integer(), none……         |
element_2_none_2(N, Tup) ->                | OK      |
    element(N, Tup).                       |         |
                                           |         |
-spec map_get_2_1(                         |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
map_get_2_1(K, M) ->                       | OK      |
    maps:get(K, M).                        |         |
                                           |         |
-spec map_get_2_2_neg(                     |         |
    pid(), #{pid() => number()}            |         |
) -> atom().                               |         |
map_get_2_2_neg(K, M) ->                   | ERROR   |
    maps:get(K, M).                        |         | maps:get(K, M).
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec map_get_2_3(                         |         |
    #{a => atom(), n => number()}          |         |
) -> {atom(), number()}.                   |         |
map_get_2_3(M) ->                          | OK      |
    {maps:get(a, M), maps:get(n, M)}.      |         |
                                           |         |
-spec map_get_2_4(                         |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
map_get_2_4(K, M) ->                       | OK      |
    Res = maps:get(K, M),                  |         |
    Res.                                   |         |
                                           |         |
-spec map_get_2_5_neg(                     |         |
    pid(), #{pid() => number()}            |         |
) -> atom().                               |         |
map_get_2_5_neg(K, M) ->                   | ERROR   |
    Res = maps:get(K, M),                  |         |
    Res.                                   |         | Res.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec map_get_2_6(                         |         |
    #{a => atom(), n => number()}          |         |
) -> {atom(), number()}.                   |         |
map_get_2_6(M) ->                          | OK      |
    Res = {                                |         |
        get(a, M),                         |         |
        get(n, M)                          |         |
    },                                     |         |
    Res.                                   |         |
                                           |         |
-spec map_get_2_6_2(                       |         |
    #{a => atom(), n => number()}          |         |
) -> {atom(), number()}.                   |         |
map_get_2_6_2(M) ->                        | OK      |
    Res = {                                |         |
        map_get(a, M),                     |         |
        map_get(n, M)                      |         |
    },                                     |         |
    Res.                                   |         |
                                           |         |
-spec map_get_2_7_neg(                     |         |
    term()                                 |         |
) -> term().                               |         |
map_get_2_7_neg(M) ->                      | ERROR   |
    get(a, M).                             |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
                                           |         |
-spec map_get_2_8_neg(                     |         |
    term()                                 |         |
) -> term().                               |         |
map_get_2_8_neg(M) ->                      | ERROR   |
    Res = maps:get(a, M),                  |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
    Res.                                   |         |
                                           |         |
-spec map_get_2_9_neg(                     |         |
    term()                                 |         |
) -> term().                               |         |
map_get_2_9_neg(M) ->                      | ERROR   |
    maps:get(a, M, false).                 |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
                                           |         |
-spec map_get_2_10_neg(                    |         |
    term()                                 |         |
) -> term().                               |         |
map_get_2_10_neg(M) ->                     | ERROR   |
    Res = maps:get(a, M, false),           |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
    Res.                                   |         |
                                           |         |
-spec map_get_2_11(                        |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
map_get_2_11(K, M) ->                      | OK      |
    maps:get(K, M, undefined).             |         |
                                           |         |
-spec map_get_2_12(                        |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
map_get_2_12(K, M) ->                      | OK      |
    Res = maps:get(K, M, undefined),       |         |
    Res.                                   |         |
                                           |         |
-spec map_get_2_13_neg(                    |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
map_get_2_13_neg(K, M) ->                  | ERROR   |
    maps:get(K, M, 0).                     |         | maps:get(K, M, 0).
                                           |         | Expression has type:   atom() | number()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   atom() | number() is not compatible with atom()
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
-spec map_get_2_14_neg(                    |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
map_get_2_14_neg(K, M) ->                  | ERROR   |
    Res = maps:get(K, M, 0),               |         |
    Res.                                   |         | Res.
                                           |         | Expression has type:   atom() | number()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   atom() | number() is not compatible with atom()
                                           |         |   because
                                           |         |   number() is not compatible with atom()
                                           |         |
-spec map_get_3_15(                        |         |
    #{a => atom(), n => number()}          |         |
) -> {atom(), number()}.                   |         |
map_get_3_15(M) ->                         | ERROR   |
    {                                      |         | {maps:get('a', M, 'undefined'), maps:get('n', M, 'undefined')}.
                                           |         | Expression has type:   {atom(), number() | 'undefined'}
                                           |         | Context expected type: {atom(), number()}
                                           |         | 
                                           |         |   at tuple index 2:
                                           |         |   {atom(), number() | 'undefined'} is not compatible with {atom(), number()}
                                           |         |   because
                                           |         |   number() | 'undefined' is not compatible with number()
                                           |         |   because
                                           |         |   'undefined' is not compatible with number()
        maps:get(a, M, undefined),         |         |
        maps:get(n, M, undefined)          |         |
    }.                                     |         |
                                           |         |
-spec keydelete() ->                       |         |
    [{key, value}].                        |         |
keydelete() ->                             | OK      |
    Res = lists:keydelete(                 |         |
        key,                               |         |
        1,                                 |         |
        [{key, value}]                     |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keyreplace() ->                      |         |
    [{key1, value1} | {key2, value2}].     |         |
keyreplace() ->                            | OK      |
    Res = lists:keyreplace(                |         |
        key,                               |         |
        1,                                 |         |
        [{key1, value1}],                  |         |
        {key2, value2}                     |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keyfind_1() -> false | term().       |         |
keyfind_1() ->                             | OK      |
    Res = lists:keyfind(a, 1, []),         |         |
    Res.                                   |         |
                                           |         |
-spec keyfind_2() -> false | {c, d}.       |         |
keyfind_2() ->                             | OK      |
    Res = lists:keyfind(a, 1, [{c, d}]),   |         |
    Res.                                   |         |
                                           |         |
% We could error here by bounding          |         |
% third param <: [tuple]                   |         |
-spec keyfind_3_wip_neg() -> term().       |         |
keyfind_3_wip_neg() ->                     | OK      |
    lists:keyfind(a, 1, [#{}]).            |         |
                                           |         |
-record(rec, {field :: number()}).         |         |
                                           |         |
-spec keyfind_4() ->                       |         |
    false | #rec{}.                        |         |
keyfind_4() ->                             | OK      |
    Res = lists:keyfind(                   |         |
        a,                                 |         |
        #rec.field,                        |         |
        [#rec{field = 4}]                  |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keyfind_5() ->                       |         |
    false | {c, d} | {e, f}.               |         |
keyfind_5() ->                             | OK      |
    Res = lists:keyfind(                   |         |
        a,                                 |         |
        1,                                 |         |
        [{c, d}, {e, f}]                   |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keysearch_1() ->                     |         |
    false | {value, term()}.               |         |
keysearch_1() ->                           | OK      |
    Res = lists:keysearch(a, 1, []),       |         |
    Res.                                   |         |
                                           |         |
-spec keysearch_2() ->                     |         |
    false | {value, {c, d}}.               |         |
keysearch_2() ->                           | OK      |
    Res = lists:keysearch(a, 1, [{c, d}]), |         |
    Res.                                   |         |
                                           |         |
-spec keysearch_3_neg() -> nok.            |         |
keysearch_3_neg() ->                       | ERROR   |
    Res = lists:keysearch(a, 1, [#{}]),    |         |
    Res.                                   |         | Res.
                                           |         | Expression has type:   {'value', #S{}} | 'false'
                                           |         | Context expected type: 'nok'
                                           |         |
-spec keysearch_4() ->                     |         |
    false | {value, #rec{}}.               |         |
keysearch_4() ->                           | OK      |
    Res = lists:keysearch(                 |         |
        a,                                 |         |
        #rec.field,                        |         |
        [#rec{field = 4}]                  |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keysearch_5() ->                     |         |
    false | {value, {c, d} | {e, f}}.      |         |
keysearch_5() ->                           | OK      |
    Res = lists:keysearch(                 |         |
        a,                                 |         |
        1,                                 |         |
        [{c, d}, {e, f}]                   |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
                                           |         |
-spec keystore_1() ->                      |         |
    [{a, b} | {c, d} | {replacement}].     |         |
keystore_1() ->                            | OK      |
    Res = lists:keystore(                  |         |
        a, 1,                              |         |
        [{a, b}, {c, d}],                  |         |
        {replacement}                      |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec maps_filter_2_1()                    |         |
        -> #{number() => atom()}.          |         |
maps_filter_2_1() ->                       | OK      |
    M = #{1 => a, 2 => b},                 |         |
    F = fun erlang:'=:='/2,                |         |
    maps:filter(F, M).                     |         |
                                           |         |
-spec maps_filter_2_2()                    |         |
        -> #{number() => atom()}.          |         |
maps_filter_2_2() ->                       | OK      |
    M = #{1 => a, 2 => b},                 |         |
    maps:filter(                           |         |
        fun (K, V) -> K =:= V end,         |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filter_2_3_neg()                |         |
        -> #{number() => atom()}.          |         |
maps_filter_2_3_neg() ->                   | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    maps:filter(                           |         |
        fun (_, _) -> self() end,          |         | erlang:self().
                                           |         | Expression has type:   pid()
                                           |         | Context expected type: boolean()
        M                                  |         |
    ).                                     |         |
                                           |         |
% should pass if we fully support          |         |
%  lambdas assigned to vars                |         |
-spec maps_filter_2_4_wip()                |         |
        -> #{number() => atom()}.          |         |
maps_filter_2_4_wip() ->                   | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    F = fun (K, V) -> K =:= V end,         |         |
    maps:filter(F, M).                     |         | F.
                                           |         | Expression has type:   fun((none(), none()) -> term())
                                           |         | Context expected type: fun((number(), 'a' | 'b') -> boolean())
                                           |         | 
                                           |         |   fun((none(), none()) -> term()) is not compatible with fun((number(), 'a' | 'b') -> boolean())
                                           |         |   because
                                           |         |   term() is not compatible with boolean()
                                           |         |
                                           |         |
-spec maps_filter_2_5_neg()                |         |
        -> #{number() => atom()}.          |         |
maps_filter_2_5_neg() ->                   | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    F = fun self/0,                        |         |
    maps:filter(F, M).                     |         | F.
                                           |         | Expression has type:   fun(() -> pid())
                                           |         | Context expected type: fun((number(), 'a' | 'b') -> boolean())
                                           |         |
-spec maps_filter_2_6_neg()                |         |
        -> #{number() => atom()}.          |         |
maps_filter_2_6_neg() ->                   | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    F = fun lists:filter/2,                |         |
    maps:filter(F, M).                     |         | F.
                                           |         | Expression has type:   fun((fun((T) -> boolean()), [T]) -> [T]) with 1 type parameter
                                           |         | Context expected type: fun((number(), 'a' | 'b') -> boolean()) with 0 type parameters
                                           |         |
-spec maps_filter_2_7(                     |         |
    #{K => V}                              |         |
) -> #{K => V}.                            |         |
maps_filter_2_7(M) ->                      | OK      |
    F = fun erlang:'=:='/2,                |         |
    maps:filter(F, M).                     |         |
                                           |         |
-spec maps_filter_2_8(                     |         |
    #{K => V}                              |         |
) -> #{K => V}.                            |         |
maps_filter_2_8(M) ->                      | OK      |
    maps:filter(fun erlang:'=:='/2, M).    |         |
                                           |         |
-spec maps_filter_2_9_neg(                 |         |
    boolean(),                             |         |
    #{K => V}                              |         |
) -> #{K => V}.                            |         |
maps_filter_2_9_neg(B, M) ->               | ERROR   |
    X = case B of                          |         |
            true -> M;                     |         |
            false -> a                     |         |
        end,                               |         |
    maps:filter(fun erlang:'=:='/2, X).    |         | X.
                                           |         | Expression has type:   #D{K => V} | 'a'
                                           |         | Context expected type: #D{term() => term()}
                                           |         | 
                                           |         |   #D{K => V} | 'a' is not compatible with #D{term() => term()}
                                           |         |   because
                                           |         |   'a' is not compatible with #D{term() => term()}
                                           |         |
-spec maps_filter_2_8()                    |         |
        -> #{a => a, b => b}.              |         |
maps_filter_2_8() ->                       | OK      |
    M = #{a => a, b => b},                 |         |
    F = fun erlang:'=:='/2,                |         |
    maps:filter(F, M).                     |         |
                                           |         |
-spec maps_filter_2_10_neg() -> nok.       |         |
maps_filter_2_10_neg() ->                  | ERROR   |
    F = fun erlang:'=:='/2,                |         |
    maps:filter(F, non_kv),                |         | 'non_kv'.
                                           |         | Expression has type:   'non_kv'
                                           |         | Context expected type: #D{term() => term()}
    nok.                                   |         |
                                           |         |
-spec map_filter_empty(Pred) -> Map when   |         |
    Pred :: fun((Key, Value) -> boolean())……         |
    Map :: #{Key => Value}.                |         |
map_filter_empty(Pred) ->                  | OK      |
    maps:filter(Pred, #{}).                |         |
                                           |         |
-spec maps_map_2_1()                       |         |
        -> #{number() => boolean()}.       |         |
maps_map_2_1() ->                          | OK      |
    M = #{1 => a, 2 => b},                 |         |
    F = fun erlang:'=:='/2,                |         |
    maps:map(F, M).                        |         |
                                           |         |
-spec maps_map_2_2()                       |         |
        -> #{number() => boolean()}.       |         |
maps_map_2_2() ->                          | OK      |
    M = #{1 => a, 2 => b},                 |         |
    maps:map(                              |         |
        fun (K, V) -> K =:= V end,         |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_map_2_3_neg()                   |         |
        -> #{number() => boolean()}.       |         |
maps_map_2_3_neg() ->                      | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    maps:map(                              |         | maps:map(fun, M).
                                           |         | Expression has type:   #D{number() => pid()}
                                           |         | Context expected type: #D{number() => boolean()}
                                           |         | 
                                           |         |   #D{number() => pid()} is not compatible with #D{number() => boolean()}
                                           |         |   because
                                           |         |   pid() is not compatible with boolean()
        fun (_, _) -> self() end,          |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
% should pass if we fully support          |         |
%  lambdas assigned to vars                |         |
-spec maps_map_2_4_wip()                   |         |
        -> #{number() => boolean()}.       |         |
maps_map_2_4_wip() ->                      | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    F = fun (K, V) -> K =:= V end,         |         |
    maps:map(F, M).                        |         | F.
                                           |         | Expression has type:   fun((none(), none()) -> term())
                                           |         | Context expected type: fun((number(), 'a' | 'b') -> term())
                                           |         | 
                                           |         |   fun((none(), none()) -> term()) is not compatible with fun((number(), 'a' | 'b') -> term())
                                           |         |   because
                                           |         |   number() is not compatible with none()
                                           |         |
                                           |         |
-spec maps_map_2_5_neg()                   |         |
        -> #{number() => boolean()}.       |         |
maps_map_2_5_neg() ->                      | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    F = fun self/0,                        |         |
    maps:map(F, M).                        |         | F.
                                           |         | Expression has type:   fun(() -> pid())
                                           |         | Context expected type: fun((number(), 'a' | 'b') -> term())
                                           |         |
-spec maps_map_2_6_neg()                   |         |
        -> #{number() => boolean()}.       |         |
maps_map_2_6_neg() ->                      | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    F = fun lists:map/2,                   |         |
    maps:map(F, M).                        |         | F.
                                           |         | Expression has type:   fun((fun((A) -> B), [A]) -> [B]) with 2 type parameters
                                           |         | Context expected type: fun((number(), 'a' | 'b') -> term()) with 0 type parameters
                                           |         |
-spec maps_map_2_7(                        |         |
    #{K => term()}                         |         |
) -> #{K => boolean()}.                    |         |
maps_map_2_7(M) ->                         | OK      |
    F = fun erlang:'=:='/2,                |         |
    maps:map(F, M).                        |         |
                                           |         |
% return ty of maps:map/2                  |         |
% is always DictMap                        |         |
-spec maps_map_2_9_neg()                   |         |
        -> #{a => a, b => b}.              |         |
maps_map_2_9_neg() ->                      | ERROR   |
    M = #{a => a, b => b},                 |         |
    F = fun erlang:'=:='/2,                |         |
    maps:map(F, M).                        |         | maps:map(F, M).
                                           |         | Expression has type:   dict  map #D{atom() => boolean()}
                                           |         | Context expected type: shape map #S{a => 'a', b => 'b'}
                                           |         |
-spec maps_map_2_10_neg()                  |         |
        -> nok.                            |         |
maps_map_2_10_neg() ->                     | ERROR   |
    F = fun erlang:'=:='/2,                |         |
    maps:map(F, non_kv),                   |         | 'non_kv'.
                                           |         | Expression has type:   'non_kv'
                                           |         | Context expected type: #D{term() => term()}
    nok.                                   |         |
                                           |         |
-spec maps_fold_3_1()                      |         |
        -> [number() | a | b].             |         |
maps_fold_3_1() ->                         | OK      |
    M = #{1 => a, 2 => b},                 |         |
    X = M,                                 |         |
    Res = maps:fold(                       |         |
        fun (K, V, Acc) ->                 |         |
            [K, V] ++ Acc                  |         |
        end, [], X),                       |         |
    Res.                                   |         |
                                           |         |
-spec maps_fold_3_2_neg()                  |         |
        -> [number() | a | b].             |         |
maps_fold_3_2_neg() ->                     | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    maps:fold(                             |         |
        fun (K, V) -> [K, V] end, [], M).  |         | fun.
                                           |         | fun with arity 2 used as fun with 3 arguments
                                           |         |
-spec maps_fold_3_3_neg()                  |         |
        -> [number() | a | b].             |         |
maps_fold_3_3_neg() ->                     | ERROR   |
    M = #{1 => a, 2 => b},                 |         |
    maps:fold(                             |         |
        fun (_, _, Acc) -> [Acc] end,      |         | [Acc].
                                           |         | Expression has type:   [[[[]]]]
                                           |         | Context expected type: [[[]]]
                                           |         | 
                                           |         |   [[[[]]]] is not compatible with [[[]]]
                                           |         |   because
                                           |         |   [[[]]] is not compatible with [[]]
                                           |         |   because
                                           |         |   [[]] is not compatible with []
        [],                                |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_3_5_neg() -> nok.          |         |
maps_fold_3_5_neg() ->                     | ERROR   |
    maps:fold(                             |         |
        fun (_, _, Acc) -> Acc end,        |         |
        [],                                |         |
        non_kv                             |         | 'non_kv'.
                                           |         | Expression has type:   'non_kv'
                                           |         | Context expected type: #D{term() => term()}
    ).                                     |         |
                                           |         |
-spec maps_fold_3_6(none()) ->             |         |
    #{number() => number()}.               |         |
maps_fold_3_6(None) ->                     | OK      |
    maps:fold(                             |         |
        None,                              |         |
        #{},                               |         |
        #{1 => 1}                          |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_3_7(none()) -> none().     |         |
maps_fold_3_7(None) ->                     | OK      |
    maps:fold(                             |         |
        None,                              |         |
        None,                              |         |
        None                               |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_4_neg                      |         |
    (#{atom => atom()}) -> atom().         |         |
maps_fold_4_neg(M) ->                      | ERROR   |
    maps:fold(                             |         | maps:fold(fun, [], M).
                                           |         | Expression has type:   [] | atom()
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   [] | atom() is not compatible with atom()
                                           |         |   because
                                           |         |   [] is not compatible with atom()
        fun (_K, A, _Acc) -> A end,        |         |
        [],                                |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec folder_good(_, _, _) -> number().    |         |
folder_good(_, _, _) -> 1.                 | OK      |
                                           |         |
-spec folder_bad(_, _, Acc) -> [Acc].      |         |
folder_bad(_, _, Acc) -> [Acc].            | OK      |
                                           |         |
-spec maps_fold_3_8() -> number().         |         |
maps_fold_3_8() ->                         | OK      |
    maps:fold(                             |         |
        fun folder_good/3,                 |         |
        0,                                 |         |
        #{1 => a}                          |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_3_9_neg() -> term().       |         |
maps_fold_3_9_neg() ->                     | ERROR   |
    maps:fold(                             |         |
        fun folder_bad/3,                  |         | folder_bad/3.
                                           |         | Expression has type:   fun((term(), term(), Acc) -> [Acc]) with 1 type parameter
                                           |         | Context expected type: fun((number(), 'a', []) -> term()) with 0 type parameters
        [],                                |         |
        #{1 => a}                          |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_4_1(#{atom() => {b, binary……         |
maps_fold_4_1(M) ->                        | OK      |
    maps:fold(                             |         |
        fun                                |         |
            (K, {i, I}, Acc) ->            |         |
                maps:put(K, I, Acc);       |         |
            (K, {b, B}, Acc) ->            |         |
                maps:put(K, B, Acc)        |         |
        end,                               |         |
        #{},                               |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_4_2(#{atom() => {b, binary……         |
maps_fold_4_2(M) ->                        | OK      |
    maps:fold(                             |         |
        fun                                |         |
            (K, {i, I}, Acc) ->            |         |
                maps:put(K, I, Acc);       |         |
            (K, {b, B}, Acc) ->            |         |
                maps:put(K, B, Acc);       |         |
            (K, {a, A}, Acc) ->            |         |
                maps:put(K, A, Acc)        |         |
        end,                               |         |
        #{},                               |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_fold_4_3_neg(#{atom() => {b, bi……         |
maps_fold_4_3_neg(M) ->                    | ERROR   |
    maps:fold(                             |         | maps:fold(fun, [], M).
                                           |         | Expression has type:   [number() | binary() | atom()]
                                           |         | Context expected type: [binary()] | [number()] | [atom()]
                                           |         | 
                                           |         |   [number() | binary() | atom()] is not compatible with [binary()] | [number()] | [atom()]
                                           |         |   because
                                           |         |   [number() | binary() | atom()] is not compatible with [binary()]
                                           |         |   because
                                           |         |   number() | binary() | atom() is not compatible with binary()
                                           |         |   because
                                           |         |   number() is not compatible with binary()
        fun                                |         |
            (_K, {i, I}, Acc) ->           |         |
                [I | Acc];                 |         |
            (_K, {b, B}, Acc) ->           |         |
                [B | Acc];                 |         |
            (_K, {a, A}, Acc) ->           |         |
                [A | Acc]                  |         |
        end,                               |         |
        [],                                |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec lists_filtermap_1() -> [number()].   |         |
lists_filtermap_1() ->                     | OK      |
    lists:filtermap(                       |         |
        fun is_function/1, [1, 2]          |         |
    ).                                     |         |
                                           |         |
-spec lists_filtermap_2() ->               |         |
    [number() | a].                        |         |
lists_filtermap_2() ->                     | OK      |
    lists:filtermap(                       |         |
        fun (1) -> {true, a} end,          |         |
        [1, 2, 3]                          |         |
    ).                                     |         |
                                           |         |
-spec lists_filtermap_2_neg() ->           |         |
    [number() | a].                        |         |
lists_filtermap_2_neg() ->                 | ERROR   |
    lists:filtermap(                       |         |
        fun erlang:binary_to_list/1,       |         | erlang:binary_to_list/1.
                                           |         | Expression has type:   fun((binary()) -> [number()])
                                           |         | Context expected type: fun((number()) -> boolean() | {'true', term()})
                                           |         | 
                                           |         |   fun((binary()) -> [number()]) is not compatible with fun((number()) -> boolean() | {'true', term()})
                                           |         |   because
                                           |         |   [number()] is not compatible with boolean() | {'true', term()}
                                           |         |   because
                                           |         |   [number()] is not compatible with boolean()
        [1, 2, 3]                          |         |
    ).                                     |         |
                                           |         |
-spec lists_filtermap_3() ->               |         |
    [a | number()].                        |         |
lists_filtermap_3() ->                     | OK      |
    lists:filtermap(                       |         |
        fun (1) -> {true, a};              |         |
            (2) -> true end,               |         |
        [1, 2, 3]                          |         |
    ).                                     |         |
                                           |         |
-spec lists_filtermap_4_neg() -> nok.      |         |
lists_filtermap_4_neg() ->                 | ERROR   |
    lists:filtermap(                       |         |
        fun (1) -> {true, a};              |         |
            (2) -> true;                   |         |
            (3) -> wrong_ret end,          |         | 'wrong_ret'.
                                           |         | Expression has type:   'wrong_ret'
                                           |         | Context expected type: boolean() | {'true', term()}
                                           |         | 
                                           |         |   'wrong_ret' is not compatible with boolean() | {'true', term()}
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean()
        [1, 2, 3]                          |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec lists_filtermap_5_neg() -> nok.      |         |
lists_filtermap_5_neg() ->                 | ERROR   |
    lists:filtermap(                       |         |
        fun (1) -> {true, a};              |         |
            (2) -> true end,               |         |
        not_a_list                         |         | 'not_a_list'.
                                           |         | Expression has type:   'not_a_list'
                                           |         | Context expected type: [term()]
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec lists_filtermap_6_neg() -> nok.      |         |
lists_filtermap_6_neg() ->                 | OK      |
    lists:filtermap(                       |         |
        fun (wrong_arity) ->               |         |
            {true, a}                      |         |
        end,                               |         |
        [1, 2, 3]                          |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec lists_filtermap_7() ->               |         |
    nok.                                   |         |
lists_filtermap_7() ->                     | OK      |
    lists:filtermap(                       |         |
        fun (1) -> {true, a};              |         |
            (X) -> case X of               |         |
                       true ->             |         |
                           {true, a};      |         |
                       false ->            |         |
                           false           |         |
                   end                     |         |
        end,                               |         |
        [1, 2, 3]                          |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec lists_filtermap_8_neg() ->           |         |
    nok.                                   |         |
lists_filtermap_8_neg() ->                 | ERROR   |
    lists:filtermap(                       |         |
        fun (1) -> {true, a};              |         |
            (X) ->                         |         |
                Res = case X of            |         |
                       true ->             |         |
                           {true, a};      |         |
                       false ->            |         |
                           wrong_ret       |         |
                   end,                    |         |
                Res                        |         | Res.
                                           |         | Expression has type:   {'true', 'a'} | 'wrong_ret'
                                           |         | Context expected type: boolean() | {'true', term()}
                                           |         | 
                                           |         |   {'true', 'a'} | 'wrong_ret' is not compatible with boolean() | {'true', term()}
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean() | {'true', term()}
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean()
        end,                               |         |
        [1, 2, 3]                          |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec ab_queue() -> queue:queue(a | b).    |         |
ab_queue() ->                              | OK      |
    throw(not_implemented).                |         |
                                           |         |
-spec queue_filter_1() -> queue:queue(a | ……         |
queue_filter_1() ->                        | OK      |
    queue:filter(                          |         |
        fun is_function/1, ab_queue()      |         |
    ).                                     |         |
                                           |         |
-spec queue_filter_2() ->                  |         |
    queue:queue(a | b | c).                |         |
queue_filter_2() ->                        | OK      |
    queue:filter(                          |         |
        fun (a) -> [c] end,                |         |
        ab_queue()                         |         |
    ).                                     |         |
                                           |         |
-spec queue_filter_3() ->                  |         |
    queue:queue(a | b).                    |         |
queue_filter_3() ->                        | OK      |
    queue:filter(                          |         |
        fun (a) -> union([a], [b]);        |         |
            (b) -> true end,               |         |
        ab_queue()                         |         |
    ).                                     |         |
                                           |         |
-spec queue_filter_4_neg() -> nok.         |         |
queue_filter_4_neg() ->                    | ERROR   |
    queue:filter(                          |         |
        fun (a) -> [a];                    |         | fun.
                                           |         | Expression has type:   fun(('a' | 'b') -> ['a'] | 'true' | 'wrong_ret')
                                           |         | Context expected type: fun(('a' | 'b') -> boolean() | ['a' | 'b'])
                                           |         | 
                                           |         |   fun(('a' | 'b') -> ['a'] | 'true' | 'wrong_ret') is not compatible with fun(('a' | 'b') -> boolean() | ['a' | 'b'])
                                           |         |   because
                                           |         |   ['a'] | 'true' | 'wrong_ret' is not compatible with boolean() | ['a' | 'b']
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean() | ['a' | 'b']
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean()
            (b) -> true;                   |         |
            (c) -> wrong_ret end,          |         |
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_5_neg() -> nok.         |         |
queue_filter_5_neg() ->                    | ERROR   |
    queue:filter(                          |         |
        fun (1) -> {true, a};              |         |
            (2) -> true end,               |         |
        not_a_queue                        |         | 'not_a_queue'.
                                           |         | Expression has type:   'not_a_queue'
                                           |         | Context expected type: queue:queue(Item)
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_6_neg() -> nok.         |         |
queue_filter_6_neg() ->                    | ERROR   |
    queue:filter(                          |         |
        fun (wrong, arity) ->              |         | fun.
                                           |         | fun with arity 2 used as fun with 1 arguments
            [a]                            |         |
        end,                               |         |
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_7_neg() ->              |         |
    nok.                                   |         |
queue_filter_7_neg() ->                    | ERROR   |
    queue:filter(                          |         |
        fun (1) -> {true, a};              |         | fun.
                                           |         | Expression has type:   fun(('a' | 'b') -> ['a'] | 'false' | {'true', 'a'})
                                           |         | Context expected type: fun(('a' | 'b') -> boolean() | ['a' | 'b'])
                                           |         | 
                                           |         |   fun(('a' | 'b') -> ['a'] | 'false' | {'true', 'a'}) is not compatible with fun(('a' | 'b') -> boolean() | ['a' | 'b'])
                                           |         |   because
                                           |         |   ['a'] | 'false' | {'true', 'a'} is not compatible with boolean() | ['a' | 'b']
                                           |         |   because
                                           |         |   {'true', 'a'} is not compatible with boolean() | ['a' | 'b']
                                           |         |   because
                                           |         |   {'true', 'a'} is not compatible with boolean()
            (X) -> case X of               |         |
                       true ->             |         |
                           [a];            |         |
                       false ->            |         |
                           false           |         |
                   end                     |         |
        end,                               |         |
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_8_neg() ->              |         |
    nok.                                   |         |
queue_filter_8_neg() ->                    | ERROR   |
    queue:filter(                          |         |
        fun (a) -> [a];                    |         | fun.
                                           |         | Expression has type:   fun(('a' | 'b') -> ['a'] | 'wrong_ret')
                                           |         | Context expected type: fun(('a' | 'b') -> boolean() | ['a' | 'b'])
                                           |         | 
                                           |         |   fun(('a' | 'b') -> ['a'] | 'wrong_ret') is not compatible with fun(('a' | 'b') -> boolean() | ['a' | 'b'])
                                           |         |   because
                                           |         |   ['a'] | 'wrong_ret' is not compatible with boolean() | ['a' | 'b']
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean() | ['a' | 'b']
                                           |         |   because
                                           |         |   'wrong_ret' is not compatible with boolean()
            (X) ->                         |         |
                Res = case X of            |         |
                          true ->          |         |
                              [a];         |         |
                          false ->         |         |
                              wrong_ret    |         |
                      end,                 |         |
                Res                        |         |
        end,                               |         |
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_9_neg() ->              |         |
    nok.                                   |         |
queue_filter_9_neg() ->                    | ERROR   |
    queue:filter(                          |         |
        fun list_to_atom/1,                |         | erlang:list_to_atom/1.
                                           |         | Expression has type:   fun((string()) -> atom())
                                           |         | Context expected type: fun((none()) -> boolean() | [none()])
                                           |         | 
                                           |         |   fun((string()) -> atom()) is not compatible with fun((none()) -> boolean() | [none()])
                                           |         |   because
                                           |         |   atom() is not compatible with boolean() | [none()]
                                           |         |   because
                                           |         |   atom() is not compatible with boolean()
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_10_neg() ->             |         |
    nok.                                   |         |
queue_filter_10_neg() ->                   | ERROR   |
    queue:filter(                          |         |
        fun atom_to_list/1,                |         | erlang:atom_to_list/1.
                                           |         | Expression has type:   fun((atom()) -> string())
                                           |         | Context expected type: fun((atom()) -> boolean() | [atom()])
                                           |         | 
                                           |         |   fun((atom()) -> string()) is not compatible with fun((atom()) -> boolean() | [atom()])
                                           |         |   because
                                           |         |   string() is not compatible with boolean() | [atom()]
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_11_neg() ->             |         |
    nok.                                   |         |
queue_filter_11_neg() ->                   | ERROR   |
    queue:filter(                          |         |
        fun atom_to_list/1,                |         | erlang:atom_to_list/1.
                                           |         | Expression has type:   fun((atom()) -> string())
                                           |         | Context expected type: fun((atom()) -> boolean() | [atom()])
                                           |         | 
                                           |         |   fun((atom()) -> string()) is not compatible with fun((atom()) -> boolean() | [atom()])
                                           |         |   because
                                           |         |   string() is not compatible with boolean() | [atom()]
        ab_queue()                         |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec queue_filter_12_neg(                 |         |
   queue:queue(a) | queue:queue(b)         |         |
) -> ok.                                   |         |
queue_filter_12_neg(Q) ->                  | ERROR   |
    queue:filter(                          |         |
        fun atom_to_list/1,                |         | erlang:atom_to_list/1.
                                           |         | Expression has type:   fun((atom()) -> string())
                                           |         | Context expected type: fun((atom()) -> boolean() | [atom()])
                                           |         | 
                                           |         |   fun((atom()) -> string()) is not compatible with fun((atom()) -> boolean() | [atom()])
                                           |         |   because
                                           |         |   string() is not compatible with boolean() | [atom()]
        Q                                  |         |
    ),                                     |         |
    ok.                                    |         |
                                           |         |
-spec queue_filter_13_neg(none()) -> ok.   |         |
queue_filter_13_neg(Q) ->                  | ERROR   |
    queue:filter(                          |         |
        fun atom_to_list/1,                |         | erlang:atom_to_list/1.
                                           |         | Expression has type:   fun((atom()) -> string())
                                           |         | Context expected type: fun((atom()) -> boolean() | [atom()])
                                           |         | 
                                           |         |   fun((atom()) -> string()) is not compatible with fun((atom()) -> boolean() | [atom()])
                                           |         |   because
                                           |         |   string() is not compatible with boolean() | [atom()]
        Q                                  |         |
    ),                                     |         |
    ok.                                    |         |
                                           |         |
-spec keystore_2() ->                      |         |
    [{foo, b} | {c, d} | {replacement}].   |         |
keystore_2() ->                            | OK      |
    Res = lists:keystore(                  |         |
        a, 1,                              |         |
        [{foo, b}, {c, d}],                |         |
        {replacement}                      |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keystore_3() ->                      |         |
    [{foo,b} | {c,d} | {replacement}].     |         |
keystore_3() ->                            | OK      |
    Res = lists:keystore(                  |         |
        a, 1,                              |         |
        [{foo, b}, {c, d}],                |         |
        {replacement}                      |         |
    ),                                     |         |
    Res.                                   |         |
                                           |         |
-spec keystore_4_neg() -> nok.             |         |
keystore_4_neg() ->                        | ERROR   |
    % runtime error                        |         |
    lists:keystore(                        |         |
        a, 1,                              |         |
        [{foo, b}, {c, d}],                |         |
        non_tuple                          |         | 'non_tuple'.
                                           |         | Expression has type:   'non_tuple'
                                           |         | Context expected type: tuple()
    ).                                     |         |
                                           |         |
-spec keystore_5_neg() -> nok.             |         |
keystore_5_neg() ->                        | ERROR   |
    % erl undefined behavior               |         |
    % succeeds at run time                 |         |
    % returns [non_tuple, []],             |         |
    lists:keystore(                        |         |
        a, 1,                              |         |
        [non_tuple],                       |         | ['non_tuple'].
                                           |         | Expression has type:   ['non_tuple']
                                           |         | Context expected type: [tuple()]
                                           |         | 
                                           |         |   ['non_tuple'] is not compatible with [tuple()]
                                           |         |   because
                                           |         |   'non_tuple' is not compatible with tuple()
        {replacement}                      |         |
    ).                                     |         |
                                           |         |
-spec keystore_6_neg() -> nok.             |         |
keystore_6_neg() ->                        | ERROR   |
    % runtime error                        |         |
    lists:keystore(                        |         |
        a, 1,                              |         |
        non_list,                          |         | 'non_list'.
                                           |         | Expression has type:   'non_list'
                                           |         | Context expected type: [tuple()]
        {replacement}                      |         |
    ).                                     |         |
                                           |         |
-spec keystore_7(none()) ->                |         |
    [{replacement}].                       |         |
keystore_7(None) ->                        | OK      |
    lists:keystore(                        |         |
        a, 1,                              |         |
        None,                              |         |
        {replacement}                      |         |
    ).                                     |         |
                                           |         |
-spec keystore_8(none()) -> [none()].      |         |
keystore_8(None) ->                        | OK      |
    lists:keystore(                        |         |
        a, 1,                              |         |
        None,                              |         |
        None                               |         |
    ).                                     |         |
                                           |         |
-type my_tup() :: {k1, v1} | {k2, v2}.     |         |
                                           |         |
-spec keytake_3_1(term()) ->               |         |
    {value, my_tup(),[my_tup()]} | false.  |         |
keytake_3_1(X) ->                          | OK      |
    lists:keytake(                         |         |
        X,                                 |         |
        1,                                 |         |
        [{k1, v1}, {k2, v2}]               |         |
    ).                                     |         |
                                           |         |
-spec keytake_3_2_neg() -> nok.            |         |
keytake_3_2_neg() ->                       | ERROR   |
    lists:keytake(a, 1, non_tup),          |         | 'non_tup'.
                                           |         | Expression has type:   'non_tup'
                                           |         | Context expected type: [Tuple]
    nok.                                   |         |
                                           |         |
-spec keytake_3_3_neg() -> nok.            |         |
keytake_3_3_neg() ->                       | ERROR   |
    lists:keytake(a, 1, non_list),         |         | 'non_list'.
                                           |         | Expression has type:   'non_list'
                                           |         | Context expected type: [Tuple]
    nok.                                   |         |
                                           |         |
-spec keytake_3_4_neg() -> nok.            |         |
keytake_3_4_neg() ->                       | ERROR   |
    lists:keytake(a, non_num, []),         |         | 'non_num'.
                                           |         | Expression has type:   'non_num'
                                           |         | Context expected type: number()
    nok.                                   |         |
                                           |         |
-spec sum_1() -> integer().                |         |
sum_1() ->                                 | OK      |
    lists:sum([1, 2, 3]).                  |         |
                                           |         |
-spec sum_2_neg() -> integer().            |         |
sum_2_neg() ->                             | OK      |
    lists:sum([1.0, 2, 3]).                |         |
                                           |         |
-spec sum_3() -> number().                 |         |
sum_3() ->                                 | OK      |
    lists:sum([1.0, 2, 3]).                |         |
                                           |         |
-spec sum_4_neg() -> integer().            |         |
sum_4_neg() ->                             | ERROR   |
    lists:sum([a, 1]).                     |         | ['a', 1].
                                           |         | Expression has type:   ['a' | number()]
                                           |         | Context expected type: [number()]
                                           |         | 
                                           |         |   ['a' | number()] is not compatible with [number()]
                                           |         |   because
                                           |         |   'a' | number() is not compatible with number()
                                           |         |   because
                                           |         |   'a' is not compatible with number()
                                           |         |
-spec sum_5_neg() -> integer().            |         |
sum_5_neg() ->                             | ERROR   |
    lists:sum(not_a_list).                 |         | 'not_a_list'.
                                           |         | Expression has type:   'not_a_list'
                                           |         | Context expected type: [number()]
                                           |         |
-spec max_1() -> integer().                |         |
max_1() ->                                 | OK      |
    lists:max([1, 2, 3]).                  |         |
                                           |         |
-spec max_2_neg() -> integer().            |         |
max_2_neg() ->                             | OK      |
    lists:max([1.0, 2, 3]).                |         |
                                           |         |
-spec max_3() -> number().                 |         |
max_3() ->                                 | OK      |
    lists:max([1.0, 2, 3]).                |         |
                                           |         |
-spec max_4() -> a | integer().            |         |
max_4() ->                                 | OK      |
    lists:max([a, 1]).                     |         |
                                           |         |
-spec max_5_neg() -> integer().            |         |
max_5_neg() ->                             | ERROR   |
    lists:max(not_a_list).                 |         | 'not_a_list'.
                                           |         | Expression has type:   'not_a_list'
                                           |         | Context expected type: [T]
                                           |         |
-spec min_1() -> integer().                |         |
min_1() ->                                 | OK      |
    lists:min([1, 2, 3]).                  |         |
                                           |         |
-spec min_2_neg() -> integer().            |         |
min_2_neg() ->                             | OK      |
    lists:min([1.0, 2, 3]).                |         |
                                           |         |
-spec min_3() -> number().                 |         |
min_3() ->                                 | OK      |
    lists:min([1.0, 2, 3]).                |         |
                                           |         |
-spec min_4() -> a | integer().            |         |
min_4() ->                                 | OK      |
    lists:min([a, 1]).                     |         |
                                           |         |
-spec min_5_neg() -> integer().            |         |
min_5_neg() ->                             | ERROR   |
    lists:min(not_a_list).                 |         | 'not_a_list'.
                                           |         | Expression has type:   'not_a_list'
                                           |         | Context expected type: [T]
                                           |         |
-spec test_find_shape(#{k := v}) -> v.     |         |
test_find_shape(M) ->                      | OK      |
    {ok, V} = maps:find(k, M),             |         |
    V.                                     |         |
                                           |         |
-spec test_find_dict(#{pid() => v}) -> v.  |         |
test_find_dict(M) ->                       | OK      |
    {ok, V} = maps:find(k, M),             |         |
    V.                                     |         |
                                           |         |
-type plist(K, V) :: [K | {K, V}].         |         |
                                           |         |
-spec 'test_plists_get_value/2'(           |         |
    plist(integer(), pid())) ->            |         |
        pid() | undefined.                 |         |
'test_plists_get_value/2'(L) ->            | ERROR   |
    proplists:get_value(k, L).             |         | proplists:get_value('k', L).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: pid() | 'undefined'
                                           |         | 
                                           |         |   term() is not compatible with pid() | 'undefined'
                                           |         |   because
                                           |         |   term() is not compatible with pid()
                                           |         |
-spec 'test_plists_get_value/2_overlap'(   |         |
    plist({k, v}, pid())) ->               |         |
    pid() | undefined | v.                 |         |
'test_plists_get_value/2_overlap'(L) ->    | ERROR   |
    proplists:get_value(k, L).             |         | proplists:get_value('k', L).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: pid() | 'undefined' | 'v'
                                           |         | 
                                           |         |   term() is not compatible with pid() | 'undefined' | 'v'
                                           |         |   because
                                           |         |   term() is not compatible with pid()
                                           |         |
-spec 'test_plists_get_value/2_neg'(       |         |
    plist(atom(), pid())) -> pid().        |         |
'test_plists_get_value/2_neg'(L) ->        | ERROR   |
    proplists:get_value(k, L).             |         | proplists:get_value('k', L).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: pid()
                                           |         |
-spec 'test_plists_get_value/3'(           |         |
    plist(reference(), pid())) ->          |         |
        pid() | integer().                 |         |
'test_plists_get_value/3'(L) ->            | ERROR   |
    proplists:get_value(k, L, 3).          |         | proplists:get_value('k', L, 3).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: pid() | number()
                                           |         | 
                                           |         |   term() is not compatible with pid() | number()
                                           |         |   because
                                           |         |   term() is not compatible with pid()
                                           |         |
-spec 'test_plists_get_value/3_overlap'(   |         |
    plist({k, v1}, v2)) ->                 |         |
    v1 | v2 | my_default.                  |         |
'test_plists_get_value/3_overlap'(L) ->    | ERROR   |
    proplists:get_value(k, L, my_default). |         | proplists:get_value('k', L, 'my_default').
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'v1' | 'v2' | 'my_default'
                                           |         | 
                                           |         |   term() is not compatible with 'v1' | 'v2' | 'my_default'
                                           |         |   because
                                           |         |   term() is not compatible with 'v1'
                                           |         |
-spec 'test_plists_get_value/3_neg'(       |         |
    plist(number(), v)) ->                 |         |
    v.                                     |         |
'test_plists_get_value/3_neg'(L) ->        | ERROR   |
    proplists:get_value(k, L, my_default). |         | proplists:get_value('k', L, 'my_default').
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'v'
                                           |         |
-spec 'test_plists_get_value/2_2_neg'()    |         |
        -> term().                         |         |
'test_plists_get_value/2_2_neg'() ->       | ERROR   |
    proplists:get_value(k, b).             |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec 'test_plists_get_value/2_3'()        |         |
        -> default.                        |         |
'test_plists_get_value/2_3'() ->           | ERROR   |
    proplists:get_value(k, []).            |         | proplists:get_value('k', []).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'default'
                                           |         |
-spec 'test_plists_get_value/3_2'()        |         |
        -> my_default.                     |         |
'test_plists_get_value/3_2'() ->           | ERROR   |
proplists:get_value(k, [], my_default).    |         | proplists:get_value('k', [], 'my_default').
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'my_default'
                                           |         |
-spec 'test_plists_get_value/3_2_neg'()    |         |
        -> term().                         |         |
'test_plists_get_value/3_2_neg'() ->       | ERROR   |
    proplists:get_value(k, b, my_default). |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_get_bool1_neg            |         |
    (plist(a, b)) -> true.                 |         |
test_plists_get_bool1_neg(L) ->            | ERROR   |
    proplists:get_bool(b, L).              |         | proplists:get_bool('b', L).
                                           |         | Expression has type:   boolean()
                                           |         | Context expected type: 'true'
                                           |         |
-spec test_plists_get_all_values(          |         |
    plist(integer(), pid())) ->            |         |
    [pid() | default].                     |         |
test_plists_get_all_values(L) ->           | ERROR   |
    proplists:get_all_values(k, L).        |         | proplists:get_all_values('k', L).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: [pid() | 'default']
                                           |         | 
                                           |         |   [term()] is not compatible with [pid() | 'default']
                                           |         |   because
                                           |         |   term() is not compatible with pid() | 'default'
                                           |         |   because
                                           |         |   term() is not compatible with pid()
                                           |         |
-spec test_plists_get_all_values2(         |         |
    plist({k, v}, pid())) ->               |         |
    [pid() | default | v].                 |         |
test_plists_get_all_values2(L) ->          | ERROR   |
    proplists:get_all_values(k, L).        |         | proplists:get_all_values('k', L).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: [pid() | 'default' | 'v']
                                           |         | 
                                           |         |   [term()] is not compatible with [pid() | 'default' | 'v']
                                           |         |   because
                                           |         |   term() is not compatible with pid() | 'default' | 'v'
                                           |         |   because
                                           |         |   term() is not compatible with pid()
                                           |         |
-spec test_plists_get_all_values3(         |         |
    plist(atom(), pid())) -> [pid()].      |         |
test_plists_get_all_values3(L) ->          | ERROR   |
    proplists:get_all_values(k, L).        |         | proplists:get_all_values('k', L).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: [pid()]
                                           |         | 
                                           |         |   [term()] is not compatible with [pid()]
                                           |         |   because
                                           |         |   term() is not compatible with pid()
                                           |         |
-spec test_plists_get_all_values4()        |         |
        -> [].                             |         |
test_plists_get_all_values4() ->           | ERROR   |
    proplists:get_all_values(k, []).       |         | proplists:get_all_values('k', []).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: []
                                           |         |
-spec test_plists_get_all_values5_neg()    |         |
        -> [].                             |         |
test_plists_get_all_values5_neg() ->       | ERROR   |
    proplists:get_all_values(k, b).        |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_get_bool2_neg()          |         |
        -> term().                         |         |
test_plists_get_bool2_neg() ->             | ERROR   |
    proplists:get_bool(b, b).              |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_get_keys1_neg            |         |
    ([a | b | {c, {d, d}}]) -> [c].        |         |
test_plists_get_keys1_neg(L) ->            | ERROR   |
    proplists:get_keys(L).                 |         | proplists:get_keys(L).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: ['c']
                                           |         | 
                                           |         |   [term()] is not compatible with ['c']
                                           |         |   because
                                           |         |   term() is not compatible with 'c'
                                           |         |
-spec test_plists_get_keys2                |         |
    ([a | b | {c, {d, d}}]) ->             |         |
        [a | b | c].                       |         |
test_plists_get_keys2(L) ->                | ERROR   |
    proplists:get_keys(L).                 |         | proplists:get_keys(L).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: ['a' | 'b' | 'c']
                                           |         | 
                                           |         |   [term()] is not compatible with ['a' | 'b' | 'c']
                                           |         |   because
                                           |         |   term() is not compatible with 'a' | 'b' | 'c'
                                           |         |   because
                                           |         |   term() is not compatible with 'a'
                                           |         |
-spec test_plists_get_keys3_neg()          |         |
        -> term().                         |         |
test_plists_get_keys3_neg() ->             | ERROR   |
    proplists:get_keys(a).                 |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_get_keys4()              |         |
        -> [a].                            |         |
test_plists_get_keys4() ->                 | ERROR   |
    proplists:get_keys(                    |         | proplists:get_keys([{'a', 'b', 'c'}]).
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: ['a']
                                           |         | 
                                           |         |   [term()] is not compatible with ['a']
                                           |         |   because
                                           |         |   term() is not compatible with 'a'
        [{a, b, c}]                        |         |
    ).                                     |         |
                                           |         |
-spec test_plists_get_values1(             |         |
    plist(reference(), a | pid())) ->      |         |
    a | pid().                             |         |
test_plists_get_values1(L) ->              | ERROR   |
    proplists:get_value(k, L).             |         | proplists:get_value('k', L).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'a' | pid()
                                           |         | 
                                           |         |   term() is not compatible with 'a' | pid()
                                           |         |   because
                                           |         |   term() is not compatible with 'a'
                                           |         |
-spec test_plists_get_values2_neg() ->     |         |
    a | pid().                             |         |
test_plists_get_values2_neg() ->           | ERROR   |
    proplists:get_value(k, b).             |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_lookup1_neg()            |         |
    -> {b, true}.                          |         |
test_plists_lookup1_neg() ->               | ERROR   |
proplists:lookup(self(), [a, {b, true}]).  |         | proplists:lookup(erlang:self(), ['a', {'b', 'true'}]).
                                           |         | Expression has type:   'none' | tuple()
                                           |         | Context expected type: {'b', 'true'}
                                           |         |
-spec test_plists_lookup2_neg() -> term(). |         |
test_plists_lookup2_neg() ->               | ERROR   |
    proplists:lookup(a, b).                |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_lookup3()                |         |
        -> none | {a, true} | {b, true}.   |         |
test_plists_lookup3() ->                   | ERROR   |
proplists:lookup(self(), [a, {b, true}]).  |         | proplists:lookup(erlang:self(), ['a', {'b', 'true'}]).
                                           |         | Expression has type:   'none' | tuple()
                                           |         | Context expected type: 'none' | {'a', 'true'} | {'b', 'true'}
                                           |         | 
                                           |         |   'none' | tuple() is not compatible with 'none' | {'a', 'true'} | {'b', 'true'}
                                           |         |   because
                                           |         |   tuple() is not compatible with 'none' | {'a', 'true'} | {'b', 'true'}
                                           |         |   because
                                           |         |   tuple() is not compatible with 'none'
                                           |         |
-spec test_plists_lookup4()                |         |
        -> none.                           |         |
test_plists_lookup4() ->                   | ERROR   |
    proplists:lookup(k, []).               |         | proplists:lookup('k', []).
                                           |         | Expression has type:   'none' | tuple()
                                           |         | Context expected type: 'none'
                                           |         | 
                                           |         |   'none' | tuple() is not compatible with 'none'
                                           |         |   because
                                           |         |   tuple() is not compatible with 'none'
                                           |         |
-spec test_plists_lookup_all1_neg()        |         |
        -> [{b, true}].                    |         |
test_plists_lookup_all1_neg() ->           | ERROR   |
    proplists:lookup_all(                  |         | proplists:lookup_all(erlang:self(), ['a', {'b', 'true'}]).
                                           |         | Expression has type:   [tuple()]
                                           |         | Context expected type: [{'b', 'true'}]
                                           |         | 
                                           |         |   [tuple()] is not compatible with [{'b', 'true'}]
                                           |         |   because
                                           |         |   tuple() is not compatible with {'b', 'true'}
        self(),                            |         |
        [a, {b, true}]                     |         |
    ).                                     |         |
                                           |         |
-spec test_plists_lookup_all2_neg()        |         |
        -> term().                         |         |
test_plists_lookup_all2_neg() ->           | ERROR   |
    proplists:lookup_all(a, b).            |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_lookup_all3()            |         |
        -> [{a, true} | {b, true}].        |         |
test_plists_lookup_all3() ->               | ERROR   |
    proplists:lookup_all(                  |         | proplists:lookup_all(erlang:self(), ['a', {'b', 'true'}]).
                                           |         | Expression has type:   [tuple()]
                                           |         | Context expected type: [{'a', 'true'} | {'b', 'true'}]
                                           |         | 
                                           |         |   [tuple()] is not compatible with [{'a', 'true'} | {'b', 'true'}]
                                           |         |   because
                                           |         |   tuple() is not compatible with {'a', 'true'} | {'b', 'true'}
                                           |         |   because
                                           |         |   tuple() is not compatible with {'a', 'true'}
        self(),                            |         |
        [a, {b, true}]                     |         |
    ).                                     |         |
                                           |         |
-spec test_plists_lookup_all4()            |         |
        -> [].                             |         |
test_plists_lookup_all4() ->               | ERROR   |
    proplists:lookup_all(                  |         | proplists:lookup_all(erlang:self(), []).
                                           |         | Expression has type:   [tuple()]
                                           |         | Context expected type: []
        self(),                            |         |
        []                                 |         |
    ).                                     |         |
                                           |         |
-spec test_plists_is_defined1() ->         |         |
    boolean().                             |         |
test_plists_is_defined1() ->               | OK      |
    proplists:is_defined(self(), []).      |         |
                                           |         |
-spec test_plists_is_defined2() ->         |         |
    boolean().                             |         |
test_plists_is_defined2() ->               | OK      |
    proplists:is_defined(self(), [a]).     |         |
                                           |         |
-spec test_plists_is_defined3() ->         |         |
    boolean().                             |         |
test_plists_is_defined3() ->               | OK      |
    proplists:is_defined(                  |         |
        self(),                            |         |
        [{a, b}]                           |         |
    ).                                     |         |
                                           |         |
-spec test_plists_is_defined4_neg() ->     |         |
    boolean().                             |         |
test_plists_is_defined4_neg() ->           | ERROR   |
    proplists:is_defined(self(), b).       |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_delete1_neg() -> term(). |         |
test_plists_delete1_neg() ->               | ERROR   |
    proplists:delete(k, b).                |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [A]
                                           |         |
-spec test_plists_delete2() -> [].         |         |
test_plists_delete2() ->                   | OK      |
    proplists:delete(k, []).               |         |
                                           |         |
-spec test_plists_delete3(                 |         |
     plist(k1 | pid(), v1 | v2)            |         |
) -> plist(k1 | pid(), v1 | v2).           |         |
test_plists_delete3(L) ->                  | OK      |
    proplists:delete(k, L).                |         |
                                           |         |
-spec test_plists_split1(                  |         |
    plist(a, b), [pid()]                   |         |
) -> {[plist(a, b)], plist(a, b)}.         |         |
test_plists_split1(L, Ks) ->               | ERROR   |
    proplists:split(L, Ks).                |         | proplists:split(L, Ks).
                                           |         | Expression has type:   {[[term()]], [term()]}
                                           |         | Context expected type: {[plist('a', 'b')], plist('a', 'b')}
                                           |         | 
                                           |         |   at tuple index 1:
                                           |         |   {[[term()]], [term()]} is not compatible with {[plist('a', 'b')], plist('a', 'b')}
                                           |         |   because
                                           |         |   [[term()]] is not compatible with [plist('a', 'b')]
                                           |         |   because
                                           |         |   [term()] is not compatible with plist('a', 'b')
                                           |         |   because
                                           |         |   [term()] is not compatible with ['a' | {'a', 'b'}]
                                           |         |
-spec test_plists_split2_neg() -> term().  |         |
test_plists_split2_neg() ->                | ERROR   |
    proplists:split(b, []).                |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_split3_neg() -> term().  |         |
test_plists_split3_neg() ->                | ERROR   |
    proplists:split([], b).                |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_to_map1_neg()            |         |
    -> term().                             |         |
test_plists_to_map1_neg() ->               | ERROR   |
    proplists:to_map(b).                   |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
                                           |         |
-spec test_plists_to_map2_neg()            |         |
        -> term().                         |         |
test_plists_to_map2_neg() ->               | OK      |
    proplists:to_map([{a, b, c}]).         |         |
                                           |         |
-spec test_plists_to_map3_neg()            |         |
        -> #{a |d => b | pid()}.           |         |
test_plists_to_map3_neg() ->               | ERROR   |
    proplists:to_map(                      |         | proplists:to_map([{'a', 'b'}, 'c', {'d', erlang:self()}]).
                                           |         | Expression has type:   #D{eqwalizer:dynamic() => eqwalizer:dynamic()}
                                           |         | Context expected type: #D{'a' | 'd' => 'b' | pid()}
                                           |         | 
                                           |         |   #D{eqwalizer:dynamic() => eqwalizer:dynamic()} is not compatible with #D{'a' | 'd' => 'b' | pid()}
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with 'a' | 'd'
                                           |         |   because
                                           |         |   term() is not compatible with 'a' | 'd'
                                           |         |   because
                                           |         |   term() is not compatible with 'a'
        [{a, b}, c, {d, self()}]).         |         |
                                           |         |
-spec test_plists_to_map4()                |         |
    -> #{a | c |d => b | true | pid()}.    |         |
test_plists_to_map4() ->                   | ERROR   |
    proplists:to_map(                      |         | proplists:to_map([{'a', 'b'}, 'c', {'d', erlang:self()}]).
                                           |         | Expression has type:   #D{eqwalizer:dynamic() => eqwalizer:dynamic()}
                                           |         | Context expected type: #D{'a' | 'c' | 'd' => 'b' | 'true' | pid()}
                                           |         | 
                                           |         |   #D{eqwalizer:dynamic() => eqwalizer:dynamic()} is not compatible with #D{'a' | 'c' | 'd' => 'b' | 'true' | pid()}
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with 'a' | 'c' | 'd'
                                           |         |   because
                                           |         |   term() is not compatible with 'a' | 'c' | 'd'
                                           |         |   because
                                           |         |   term() is not compatible with 'a'
        [{a, b}, c, {d, self()}]).         |         |
                                           |         |
-spec test_plists_to_map5()                |         |
        -> #{none() => none()}.            |         |
test_plists_to_map5() ->                   | ERROR   |
    proplists:to_map([]).                  |         | proplists:to_map([]).
                                           |         | Expression has type:   #D{eqwalizer:dynamic() => eqwalizer:dynamic()}
                                           |         | Context expected type: #D{none() => none()}
                                           |         | 
                                           |         |   #D{eqwalizer:dynamic() => eqwalizer:dynamic()} is not compatible with #D{none() => none()}
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with none()
                                           |         |   because
                                           |         |   term() is not compatible with none()
                                           |         |
-spec test_plists_from_map1() ->           |         |
    plist(a | pid(), b | true).            |         |
test_plists_from_map1() ->                 | OK      |
    proplists:from_map(                    |         |
        #{a => b, self() => true}          |         |
    ).                                     |         |
                                           |         |
-spec test_plists_from_map2_neg() ->       |         |
    term().                                |         |
test_plists_from_map2_neg() ->             | ERROR   |
    proplists:from_map(b).                 |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: #D{K => V}
                                           |         |
-spec 'test_plists_get_value/2_4'()        |         |
        -> true | undefined.               |         |
'test_plists_get_value/2_4'() ->           | ERROR   |
    proplists:get_value(a, [a]).           |         | proplists:get_value('a', ['a']).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'true' | 'undefined'
                                           |         | 
                                           |         |   term() is not compatible with 'true' | 'undefined'
                                           |         |   because
                                           |         |   term() is not compatible with 'true'
                                           |         |
-spec 'test_plists_get_value/2_5'          |         |
    (atom()) -> true | undefined.          |         |
'test_plists_get_value/2_5'(X) ->          | ERROR   |
    proplists:get_value(X, [a]).           |         | proplists:get_value(X, ['a']).
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'true' | 'undefined'
                                           |         | 
                                           |         |   term() is not compatible with 'true' | 'undefined'
                                           |         |   because
                                           |         |   term() is not compatible with 'true'
                                           |         |
-spec 'test_plists_get_value/3_3'()        |         |
        -> true | b.                       |         |
'test_plists_get_value/3_3'() ->           | ERROR   |
    proplists:get_value(a, [a], b).        |         | proplists:get_value('a', ['a'], 'b').
                                           |         | Expression has type:   term()
                                           |         | Context expected type: 'true' | 'b'
                                           |         | 
                                           |         |   term() is not compatible with 'true' | 'b'
                                           |         |   because
                                           |         |   term() is not compatible with 'true'
                                           |         |
-spec app_env1_strict() -> number().       |         |
app_env1_strict() ->                       | ERROR   |
    Res = application:get_env(app1),       |         |
    case Res of                            |         |
        undefined -> 0;                    |         |
        {ok, N} -> N                       |         | N.
                                           |         | Expression has type:   eqwalizer:dynamic()
                                           |         | Context expected type: number()
                                           |         | 
                                           |         |   eqwalizer:dynamic() is not compatible with number()
                                           |         |   because
                                           |         |   term() is not compatible with number()
    end.                                   |         |
                                           |         |
-spec app_env2_strict() -> number().       |         |
app_env2_strict() ->                       | ERROR   |
    Res = application:get_env(app1, key1), |         |
    case Res of                            |         |
        undefined -> 0;                    |         |
        {ok, N} -> N                       |         | N.
                                           |         | Expression has type:   eqwalizer:dynamic()
                                           |         | Context expected type: number()
                                           |         | 
                                           |         |   eqwalizer:dynamic() is not compatible with number()
                                           |         |   because
                                           |         |   term() is not compatible with number()
    end.                                   |         |
                                           |         |
-spec app_env3_strict() -> number().       |         |
app_env3_strict() ->                       | ERROR   |
    A = app1,                              |         |
    K = key,                               |         |
    U = undefined,                         |         |
    application:get_env(A, K, U).          |         | application:get_env(A, K, U).
                                           |         | Expression has type:   eqwalizer:dynamic()
                                           |         | Context expected type: number()
                                           |         | 
                                           |         |   eqwalizer:dynamic() is not compatible with number()
                                           |         |   because
                                           |         |   term() is not compatible with number()
                                           |         |
-spec flatten1_strict() -> [atom()].       |         |
flatten1_strict() ->                       | OK      |
    In = [a, [b, c]],                      |         |
    lists:flatten(In).                     |         |
                                           |         |
-spec flatten2_strict() -> [atom()].       |         |
flatten2_strict() ->                       | OK      |
    In = [a, [b, c]],                      |         |
    Tail = [x, y, z],                      |         |
    lists:flatten(In, Tail).               |         |
                                           |         |
-spec file_consult_neg1() -> [anything].   |         |
file_consult_neg1() ->                     | ERROR   |
    {ok, Res} = file:consult(some_file),   |         |
    Res.                                   |         | Res.
                                           |         | Expression has type:   [eqwalizer:dynamic()]
                                           |         | Context expected type: ['anything']
                                           |         | 
                                           |         |   [eqwalizer:dynamic()] is not compatible with ['anything']
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with 'anything'
                                           |         |   because
                                           |         |   term() is not compatible with 'anything'
                                           |         |
-spec file_consult_neg2() -> nok.          |         |
file_consult_neg2() ->                     | ERROR   |
    file:consult(some_file).               |         | file:consult('some_file').
                                           |         | Expression has type:   {'ok', [eqwalizer:dynamic()]} | {'error', {number(), atom(), term()} | 'terminated' | 'badarg' | file:posix() | 'system_limit'}
                                           |         | Context expected type: 'nok'
                                           |         |
-spec keysort() -> [{a | b, c | d}].       |         |
keysort() ->                               | OK      |
    lists:keysort(2, [{a, c}, {b, d}]).    |         |
                                           |         |
-spec keysort2() -> [{a | b, c | d}].      |         |
keysort2() ->                              | OK      |
    lists:keysort(2, []).                  |         |
                                           |         |
-spec keysort3_neg() -> none().            |         |
keysort3_neg() ->                          | ERROR   |
    lists:keysort(2, [{a, c}, {b, d}]).    |         | lists:keysort(2, [{'a', 'c'}, {'b', 'd'}]).
                                           |         | Expression has type:   [{'a', 'c'} | {'b', 'd'}]
                                           |         | Context expected type: none()
                                           |         |
-spec keysort4_neg() -> none().            |         |
keysort4_neg() ->                          | ERROR   |
    lists:keysort(1, [3]).                 |         | [3].
                                           |         | Expression has type:   [number()]
                                           |         | Context expected type: [tuple()]
                                           |         | 
                                           |         |   [number()] is not compatible with [tuple()]
                                           |         |   because
                                           |         |   number() is not compatible with tuple()
                                           |         |
-spec gb_sets() -> gb_sets:set(number()).  |         |
gb_sets() ->                               | OK      |
    gb_sets:add(1, gb_sets:empty()).       |         |
                                           |         |
-spec filtermap_none() -> [none()].        |         |
filtermap_none() ->                        | OK      |
    lists:filtermap(                       |         |
        fun(_) -> false end,               |         |
        [1, 3, 3]                          |         |
    ).                                     |         |
                                           |         |
-spec filtermap_neg() ->                   |         |
    [integer()].                           |         |
filtermap_neg() ->                         | ERROR   |
    lists:filtermap(                       |         | lists:filtermap(fun, [1, 2, 3, 4]).
                                           |         | Expression has type:   [string() | number()]
                                           |         | Context expected type: [number()]
                                           |         | 
                                           |         |   [string() | number()] is not compatible with [number()]
                                           |         |   because
                                           |         |   string() | number() is not compatible with number()
                                           |         |   because
                                           |         |   string() is not compatible with number()
        fun(X) when X div 2 =:= 0 ->       |         |
            {true, integer_to_list(X)};    |         |
        (X) ->                             |         |
            X < 10                         |         |
        end,                               |         |
        [1, 2, 3, 4]                       |         |
    ).                                     |         |
                                           |         |
-spec filtermap_ty_change() ->             |         |
    [string()].                            |         |
filtermap_ty_change() ->                   | OK      |
    lists:filtermap(                       |         |
        fun(X) when X div 2 =:= 0 ->       |         |
            {true, integer_to_list(X)};    |         |
        (_) ->                             |         |
            false                          |         |
        end,                               |         |
        [1, 2, 3, 4]                       |         |
    ).                                     |         |
                                           |         |
-spec min1(integer(), integer()) ->        |         |
    integer().                             |         |
min1(X, Y) ->                              | OK      |
    erlang:min(X, Y).                      |         |
                                           |         |
-spec min2(atom(), integer()) ->           |         |
    atom() | integer().                    |         |
min2(X, Y) ->                              | OK      |
    erlang:min(X, Y).                      |         |
                                           |         |
-spec min3_neg(atom(), integer()) ->       |         |
    none().                                |         |
min3_neg(X, Y) ->                          | ERROR   |
    erlang:min(X, Y).                      |         | erlang:min(X, Y).
                                           |         | Expression has type:   atom() | number()
                                           |         | Context expected type: none()
                                           |         |
-spec max1(integer(), integer()) ->        |         |
    integer().                             |         |
max1(X, Y) ->                              | OK      |
    erlang:max(X, Y).                      |         |
                                           |         |
-spec max2(atom(), integer()) ->           |         |
    atom() | integer().                    |         |
max2(X, Y) ->                              | OK      |
    erlang:max(X, Y).                      |         |
                                           |         |
-spec max3_neg(atom(), integer()) ->       |         |
    none().                                |         |
max3_neg(X, Y) ->                          | ERROR   |
    erlang:max(X, Y).                      |         | erlang:max(X, Y).
                                           |         | Expression has type:   atom() | number()
                                           |         | Context expected type: none()
                                           |         |
-spec abs1(neg_integer()) ->               |         |
    non_neg_integer().                     |         |
abs1(N) ->                                 | OK      |
    abs(N).                                |         |
                                           |         |
-spec abs2(float()) -> float().            |         |
abs2(N) ->                                 | OK      |
    abs(N).                                |         |
                                           |         |
-spec abs3(number()) -> number().          |         |
abs3(N) ->                                 | OK      |
    abs(N).                                |         |
                                           |         |
-spec abs4(float()) -> non_neg_integer().  |         |
abs4(N) ->                                 | OK      |
    abs(N).                                |         |
                                           |         |
-spec abs5(integer()) ->                   |         |
    non_neg_integer().                     |         |
abs5(N) ->                                 | OK      |
    abs(N).                                |         |
                                           |         |
-spec abs6_neg(a) -> number().             |         |
abs6_neg(Atom) ->                          | ERROR   |
    abs(Atom).                             |         | Atom.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         |
-spec seq3_1_wip_neg() ->                  |         |
    [non_neg_integer()].                   |         |
seq3_1_wip_neg() -> lists:seq(-1, -2, -1). | OK      |
                                           |         |
-spec seq3_2_wip_neg() -> [pos_integer()]. |         |
seq3_2_wip_neg() -> lists:seq(0, 2, 1).    | OK      |
                                           |         |
-spec seq3_3() -> [pos_integer()].         |         |
seq3_3() -> lists:seq(1, 2, 1).            | OK      |
                                           |         |
-spec seq3_4_wip_neg() -> [integer()].     |         |
seq3_4_wip_neg() -> lists:seq(a, 2, 1).    | ERROR   | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         |
-spec seq3_5_neg() -> [integer()].         |         |
seq3_5_neg() -> lists:seq(1, a, 1).        | ERROR   | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         |
-spec seq3_6_neg() -> [integer()].         |         |
seq3_6_neg() -> lists:seq(1, 2, a).        | ERROR   | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         |
-spec seq3_7(pos_integer(),                |         |
    pos_integer()                          |         |
) -> [pos_integer()].                      |         |
seq3_7(X, Y) ->                            | OK      |
    lists:seq(X, X - Y, X).                |         |
                                           |         |
-spec seq3_7_wip_neg(non_neg_integer(),    |         |
    non_neg_integer()                      |         |
) -> [non_neg_integer()].                  |         |
seq3_7_wip_neg(X, Y) ->                    | OK      |
    lists:seq(X, X - Y, -1).               |         |
                                           |         |
-spec seq3_8_wip_neg() -> [pos_integer()]. |         |
seq3_8_wip_neg() ->                        | OK      |
    lists:seq(0, 1, 1).                    |         |
                                           |         |
-spec seq2_1_wip_neg() -> [non_neg_integer……         |
seq2_1_wip_neg() -> lists:seq(-1, -2).     | OK      |
                                           |         |
-spec seq2_2_wip_neg() -> [pos_integer()]. |         |
seq2_2_wip_neg() -> lists:seq(0, 2).       | OK      |
                                           |         |
-spec seq2_3() -> [pos_integer()].         |         |
seq2_3() -> lists:seq(1, 2).               | OK      |
                                           |         |
-spec seq2_4_wip_neg() -> [integer()].     |         |
seq2_4_wip_neg() -> lists:seq(a, 2).       | ERROR   | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         |
-spec seq2_5_neg() -> [integer()].         |         |
seq2_5_neg() -> lists:seq(1, a).           | ERROR   | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         |
-spec seq2_6(pos_integer(),                |         |
    pos_integer()                          |         |
) -> [pos_integer()].                      |         |
seq2_6(X, Y) ->                            | OK      |
    lists:seq(X, X - Y).                   |         |
                                           |         |
-spec seq2_7(non_neg_integer(),            |         |
    non_neg_integer()                      |         |
) -> [non_neg_integer()].                  |         |
seq2_7(X, Y) ->                            | OK      |
    lists:seq(X, X - Y).                   |         |
                                           |         |
-spec seq2_8() -> [pos_integer()].         |         |
seq2_8() ->                                | OK      |
    lists:seq($a, $z).                     |         |
                                           |         |
-spec seq2_9_wip_neg() -> [pos_integer()]. |         |
seq2_9_wip_neg() ->                        | OK      |
    lists:seq(0, 1).                       |         |
                                           |         |
-spec system_time0() -> pos_integer().     |         |
system_time0() ->                          | OK      |
    erlang:system_time().                  |         |
                                           |         |
-spec system_time1() -> pos_integer().     |         |
system_time1() ->                          | OK      |
    erlang:system_time(second).            |         |
                                           |         |
-spec keystore_neg() -> term().            |         |
keystore_neg() ->                          | OK      |
    lists:keystore(a, 0, [], {}).          |         |
                                           |         |
-spec keysort_neg() -> term().             |         |
keysort_neg() ->                           | OK      |
    lists:keysort(-1, []).                 |         |
                                           |         |
-spec tc1() ->                             |         |
    {integer(), result}.                   |         |
tc1() ->                                   | OK      |
    timer:tc(                              |         |
        fun() ->                           |         |
            result                         |         |
        end                                |         |
    ).                                     |         |
                                           |         |
-spec tc1_neg() -> pid().                  |         |
tc1_neg() ->                               | ERROR   |
    timer:tc(                              |         | timer:tc(fun).
                                           |         | Expression has type:   {number(), 'err'}
                                           |         | Context expected type: pid()
        fun() ->                           |         |
            err                            |         |
        end                                |         |
    ).                                     |         |
                                           |         |
-spec ets_lookup_1_neg(term()) ->          |         |
    [{whatev} | {2}].                      |         |
ets_lookup_1_neg(Any) ->                   | ERROR   |
    ets:lookup(tab, Any).                  |         | ets:lookup('tab', Any).
                                           |         | Expression has type:   [eqwalizer:dynamic()]
                                           |         | Context expected type: [{'whatev'} | {number()}]
                                           |         | 
                                           |         |   [eqwalizer:dynamic()] is not compatible with [{'whatev'} | {number()}]
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with {'whatev'} | {number()}
                                           |         |   because
                                           |         |   term() is not compatible with {'whatev'} | {number()}
                                           |         |   because
                                           |         |   term() is not compatible with {'whatev'}
                                           |         |
-spec ets_lookup_2_neg(term()) -> pid().   |         |
ets_lookup_2_neg(Any) ->                   | ERROR   |
    ets:lookup(tab, Any).                  |         | ets:lookup('tab', Any).
                                           |         | Expression has type:   [eqwalizer:dynamic()]
                                           |         | Context expected type: pid()
                                           |         |
-spec ets_lookup_3_neg(term()) -> pid().   |         |
ets_lookup_3_neg(Any) ->                   | ERROR   |
    ets:lookup("not atom", Any).           |         | string_lit.
                                           |         | Expression has type:   string()
                                           |         | Context expected type: ets:tab()
                                           |         |
-spec ets_lookup_4_neg(term()) ->          |         |
    [tuple()].                             |         |
ets_lookup_4_neg(Any) ->                   | ERROR   |
    ets:lookup(tab, Any).                  |         | ets:lookup('tab', Any).
                                           |         | Expression has type:   [eqwalizer:dynamic()]
                                           |         | Context expected type: [tuple()]
                                           |         | 
                                           |         |   [eqwalizer:dynamic()] is not compatible with [tuple()]
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with tuple()
                                           |         |   because
                                           |         |   term() is not compatible with tuple()
                                           |         |
-spec ets_lookup_5(term()) ->              |         |
    [term()].                              |         |
ets_lookup_5(Any) ->                       | OK      |
    ets:lookup(tab, Any).                  |         |
                                           |         |
-spec ets_tab2list_1_neg(atom()) ->        |         |
    [tuple()].                             |         |
ets_tab2list_1_neg(Atom) ->                | ERROR   |
    ets:tab2list(Atom).                    |         | ets:tab2list(Atom).
                                           |         | Expression has type:   [eqwalizer:dynamic()]
                                           |         | Context expected type: [tuple()]
                                           |         | 
                                           |         |   [eqwalizer:dynamic()] is not compatible with [tuple()]
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with tuple()
                                           |         |   because
                                           |         |   term() is not compatible with tuple()
                                           |         |
-spec ets_tab2list_2_neg(atom()) ->        |         |
    [{whatev} | {2}].                      |         |
ets_tab2list_2_neg(Atom) ->                | ERROR   |
    ets:tab2list(Atom).                    |         | ets:tab2list(Atom).
                                           |         | Expression has type:   [eqwalizer:dynamic()]
                                           |         | Context expected type: [{'whatev'} | {number()}]
                                           |         | 
                                           |         |   [eqwalizer:dynamic()] is not compatible with [{'whatev'} | {number()}]
                                           |         |   because
                                           |         |   eqwalizer:dynamic() is not compatible with {'whatev'} | {number()}
                                           |         |   because
                                           |         |   term() is not compatible with {'whatev'} | {number()}
                                           |         |   because
                                           |         |   term() is not compatible with {'whatev'}
                                           |         |
-spec ets_tab2list_3_neg() -> term().      |         |
ets_tab2list_3_neg() ->                    | ERROR   |
    ets:tab2list("not atom").              |         | string_lit.
                                           |         | Expression has type:   string()
                                           |         | Context expected type: ets:tab()
                                           |         |
-spec ets_tab2list_4(atom()) ->            |         |
    [term()].                              |         |
ets_tab2list_4(Atom) ->                    | OK      |
    ets:tab2list(Atom).                    |         |
                                           |         |
-spec flatten1_strict2() ->                |         |
    [atom() | number()].                   |         |
flatten1_strict2() ->                      | OK      |
    In = [a, [b, c], [1, 2, 3]],           |         |
    lists:flatten(In).                     |         |
                                           |         |
-spec flatten2_strict2() ->                |         |
    [atom() | number()].                   |         |
flatten2_strict2() ->                      | OK      |
    In = [a, [b, c]],                      |         |
    Tail = [1, 2, 3],                      |         |
    lists:flatten(In, Tail).               |         |
                                           |         |
% test flattening of aliases               |         |
-type mylist(A, B) :: [A | [A | B]].       |         |
                                           |         |
-spec flatten1_strict3(mylist(X,Y))        |         |
    -> [X | Y].                            |         |
flatten1_strict3(L) -> lists:flatten(L).   | OK      |
                                           |         |
-spec flatten2_strict3(mylist(X,Y))        |         |
    -> [X | Y | number()].                 |         |
flatten2_strict3(L) ->                     | OK      |
    lists:flatten(L, [1,2,3]).             |         |
                                           |         |
-spec flatten2_strict4(mylist(X,Y))        |         |
    -> [X | Y | [X | Y]].                  |         |
flatten2_strict4(L) ->                     | OK      |
    lists:flatten(L, L).                   |         |
                                           |         |
-spec flatten2_strict5_neg() -> term().    |         |
flatten2_strict5_neg() ->                  | ERROR   |
    lists:flatten([], 1).                  |         | 1.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: [term()]
                                           |         |
-type reclist(A) :: [A | reclist(A)].      |         |
-spec flatten1_strict4(reclist(A))         |         |
    -> [A].                                |         |
flatten1_strict4(L) -> lists:flatten(L).   | OK      |
                                           |         |
-spec flatten1_strict5_neg() -> term().    |         |
flatten1_strict5_neg() ->                  | ERROR   |
    lists:flatten(3).                      |         | 3.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: [term()]
                                           |         |
-type reclist2() :: [nil] | [reclist2()].  |         |
-spec flatten_reclist2                     |         |
    (reclist2()) -> [nil].                 |         |
flatten_reclist2(RL) ->                    | OK      |
    lists:flatten(RL).                     |         |
                                           |         |
-type reclist3(A,B) ::                     |         |
    [ {A,B} | reclist3(B,A)].              |         |
-spec flatten_reclist3_neg (reclist3(A,B)) |         |
    -> [{A,B}].                            |         |
flatten_reclist3_neg(X)                    | ERROR   |
    -> lists:flatten(X).                   |         | lists:flatten(X).
                                           |         | Expression has type:   [{A, B} | {B, A}]
                                           |         | Context expected type: [{A, B}]
                                           |         | 
                                           |         |   [{A, B} | {B, A}] is not compatible with [{A, B}]
                                           |         |   because
                                           |         |   {A, B} | {B, A} is not compatible with {A, B}
                                           |         |   because
                                           |         |   at tuple index 1:
                                           |         |   {B, A} is not compatible with {A, B}
                                           |         |   because
                                           |         |   B is not compatible with A
                                           |         |
-spec union(T, U) -> T | U.                |         |
union(T, _) -> T.                          | OK      |
                                           |         |
-type id(T) :: T.                          |         |
-type id2(T) :: id(T).                     |         |
-type infinikey(T) :: [T | infinikey(T)].  |         |
                                           |         |
-spec maps_without_1() -> #{a => ka}.      |         |
maps_without_1() ->                        | OK      |
    maps:without([], #{a => ka}).          |         |
                                           |         |
-spec maps_without_2(id2(a)) -> #{}.       |         |
maps_without_2(A) ->                       | OK      |
    maps:without([A], #{a => ka}).         |         |
                                           |         |
-spec maps_without_3() -> #{a := ka}.      |         |
maps_without_3() ->                        | OK      |
    maps:without([z], #{a => ka}).         |         |
                                           |         |
-spec maps_without_4(atom())               |         |
        -> #{b => atom()}.                 |         |
maps_without_4(Atom) ->                    | OK      |
    maps:without(                          |         |
        [a],                               |         |
        #{a => ka, b => Atom}              |         |
    ).                                     |         |
                                           |         |
-spec maps_without_5_neg(                  |         |
    atom(), d | e                          |         |
) -> #{b => atom()}.                       |         |
maps_without_5_neg(Atom, DOrE) ->          | ERROR   |
    maps:without(                          |         | maps:without(['a', 'c', DOrE], #{..}).
                                           |         | Expression has type:   #S{a => 'ka', b => atom(), c => pid(), d => 'kd'}
                                           |         | Context expected type: #S{b => atom()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    a => ...
                                           |         | +    c => ...
                                           |         | +    d => ...
                                           |         |      ...
                                           |         |   }
        [a, c, DOrE],                      |         |
        #{                                 |         |
            a => ka,                       |         |
            b => Atom,                     |         |
            c => self(),                   |         |
            d => kd                        |         |
        }                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_without_6_neg() -> term().      |         |
maps_without_6_neg() ->                    | ERROR   |
    maps:without(non_list, #{}).           |         | 'non_list'.
                                           |         | Expression has type:   'non_list'
                                           |         | Context expected type: [term()]
                                           |         |
-spec maps_without_7_neg() -> term().      |         |
maps_without_7_neg() ->                    | ERROR   |
    maps:without([], non_map).             |         | 'non_map'.
                                           |         | Expression has type:   'non_map'
                                           |         | Context expected type: #D{term() => term()}
                                           |         |
-spec maps_without_8(term()) ->            |         |
    #{atom() => ka | pid()}.               |         |
maps_without_8(Any) ->                     | OK      |
    maps:without([Any],                    |         |
        #{a => ka, b => self()}            |         |
    ).                                     |         |
                                           |         |
-spec maps_without_9(                      |         |
    #{atom() => number()}                  |         |
) -> #{atom() => number()}.                |         |
maps_without_9(D) ->                       | OK      |
    maps:without([a], D).                  |         |
                                           |         |
-spec maps_without_10(atom()) ->           |         |
    #{atom() => y | z}.                    |         |
maps_without_10(Atom) ->                   | OK      |
    maps:without(                          |         |
        [self(), w, Atom],                 |         |
        #{a => y, b => z}                  |         |
    ).                                     |         |
                                           |         |
-spec maps_without_11                      |         |
    (eqwalizer:dynamic()) ->               |         |
    #{atom() => y | z}.                    |         |
maps_without_11(Dyn) ->                    | OK      |
    maps:without(                          |         |
        [Dyn],                             |         |
        #{a => y, b => z}                  |         |
    ).                                     |         |
                                           |         |
-spec maps_without_12_neg                  |         |
    (none()) ->                            |         |
    wrong_ret.                             |         |
maps_without_12_neg(None) ->               | OK      |
    maps:without(                          |         |
        [a, b],                            |         |
        None                               |         |
    ).                                     |         |
                                           |         |
-spec maps_without_13(                     |         |
    infinikey(a)                           |         |
) -> #{b := pid()}.                        |         |
maps_without_13(Keys) ->                   | ERROR   |
    maps:without(                          |         | maps:without(Keys, #{..}).
                                           |         | Expression has type:   #S{a => pid(), b => pid()}
                                           |         | Context expected type: #S{b := pid()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    a => ...
                                           |         | -    b := ...
                                           |         | +    b => ...
                                           |         |   }
        Keys,                              |         |
        #{a => self(), b => self()}        |         |
    ).                                     |         |
                                           |         |
-spec maps_without_14_neg()                |         |
        -> #{b := pid()}.                  |         |
maps_without_14_neg() ->                   | ERROR   |
    maps:without(                          |         |
        [a | improper_tail],               |         | 'improper_tail'.
                                           |         | Expression has type:   'improper_tail'
                                           |         | Context expected type: [term()]
        #{a => self(), b => self()}        |         |
    ).                                     |         |
                                           |         |
% Some information is lost when            |         |
% the arg is not a list literal            |         |
-spec maps_without_15_neg()                |         |
    -> #{b := pid()}.                      |         |
maps_without_15_neg() ->                   | ERROR   |
    Keys = [a, b],                         |         |
    maps:without(                          |         | maps:without(Keys, #{..}).
                                           |         | Expression has type:   #S{a => 'ka', b => pid()}
                                           |         | Context expected type: #S{b := pid()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | +    a => ...
                                           |         | -    b := ...
                                           |         | +    b => ...
                                           |         |   }
        Keys,                              |         |
        #{a => ka, b => self()}            |         |
    ).                                     |         |
                                           |         |
-spec maps_without_16                      |         |
    (#{a := atom(), c := atom()}           |         |
    | #{b := atom(), c := atom()}          |         |
) -> #{c := atom()}.                       |         |
maps_without_16(M) ->                      | OK      |
    maps:without([a, b], M).               |         |
                                           |         |
-spec maps_without_17_neg                  |         |
    (#{a := av, c := cv, d := dv}          |         |
    | #{b := bv, c := cv, e => ev}         |         |
    ) -> #{c := atom()}.                   |         |
maps_without_17_neg(M) ->                  | ERROR   |
    maps:without([a, b], M).               |         | maps:without(['a', 'b'], M).
                                           |         | Expression has type:   #S{c := 'cv', d := 'dv'} | #S{c := 'cv', e => 'ev'}
                                           |         | Context expected type: #S{c := atom()}
                                           |         |
-spec maps_without_18                      |         |
    (#{a := av, b := bv})                  |         |
    -> #{a => av, b => bv}.                |         |
maps_without_18(M) ->                      | OK      |
    L = [a, c, d],                         |         |
    maps:without(L, M).                    |         |
                                           |         |
-spec maps_without_19                      |         |
    (#{a := av, b := bv})                  |         |
    -> #{a => av, b => bv}.                |         |
maps_without_19(M) ->                      | OK      |
    maps:without([a, c, d], M).            |         |
                                           |         |
-spec none() -> none().                    |         |
none() -> error(none).                     | OK      |
                                           |         |
-spec maps_without_with_none(boolean()) -> |         |
    #{id => integer()}.                    |         |
maps_without_with_none(Flag) ->            | OK      |
    M = case Flag of                       |         |
        true -> maps:without(              |         |
            [name],                        |         |
            #{id => 1, name => "name"}     |         |
        );                                 |         |
        false -> maps:without(             |         |
            [name],                        |         |
            none()                         |         |
        )                                  |         |
    end,                                   |         |
    M.                                     |         |
                                           |         |
-spec maps_without_opacity_opaque() ->     |         |
    nok.                                   |         |
maps_without_opacity_opaque() ->           | OK      |
    _ = maps:without(                      |         |
        [sets:new()],                      |         |
        #{}                                |         |
    ),                                     |         |
    nok.                                   |         |
                                           |         |
-spec custom_overloaded                    |         |
    (term()) -> term().                    |         |
custom_overloaded(A) when is_atom(A) ->    | OK      |
    atom_to_binary(A);                     |         |
custom_overloaded(B) when is_binary(B) ->  |         |
    binary_to_atom(B).                     |         |
                                           |         |
-spec use_custom_overloaded1               |         |
    (atom()) -> binary().                  |         |
use_custom_overloaded1(A) ->               | OK      |
    custom_overloaded(A).                  |         |
                                           |         |
-spec use_custom_overloaded2               |         |
    (binary()) -> atom().                  |         |
use_custom_overloaded2(B) ->               | OK      |
    custom_overloaded(B).                  |         |
                                           |         |
-spec used_custom_overloaded3_neg          |         |
    (term()) -> term().                    |         |
used_custom_overloaded3_neg(X) ->          | ERROR   |
    custom_overloaded(X).                  |         | custom_overloaded(X).
                                           |         | Not enough info to branch. Arg types: term()
                                           |         |
-spec maps_find_1(                         |         |
    pid(), #{pid() => atom()}              |         |
) -> atom().                               |         |
maps_find_1(K, M) ->                       | OK      |
    {ok, Val} = maps:find(K, M),           |         |
    Val.                                   |         |
                                           |         |
-spec maps_find_2(                         |         |
    #{a => atom(), n => number()}          |         |
) -> {atom(), number()}.                   |         |
maps_find_2(M) ->                          | OK      |
    {ok, A} = maps:find(a, M),             |         |
    {ok, N} = maps:find(n, M),             |         |
    {A, N}.                                |         |
                                           |         |
-spec maps_find_3_neg(                     |         |
    #{a => atom(), n => number() | pid()}  |         |
) -> {atom(), number()}.                   |         |
maps_find_3_neg(M) ->                      | ERROR   |
    {ok, A} = maps:find(a, M),             |         |
    {ok, N} = maps:find(n, M),             |         |
    {A, N}.                                |         | {A, N}.
                                           |         | Expression has type:   {atom(), number() | pid()}
                                           |         | Context expected type: {atom(), number()}
                                           |         | 
                                           |         |   at tuple index 2:
                                           |         |   {atom(), number() | pid()} is not compatible with {atom(), number()}
                                           |         |   because
                                           |         |   number() | pid() is not compatible with number()
                                           |         |   because
                                           |         |   pid() is not compatible with number()
                                           |         |
-spec maps_find_4(                         |         |
    term(), #{a => atom(), n => number()}  |         |
) -> atom() | number().                    |         |
maps_find_4(K, M) ->                       | OK      |
    {ok, A} = maps:find(K, M),             |         |
    A.                                     |         |
                                           |         |
-spec maps_with_1(                         |         |
    Ks :: [atom()],                        |         |
    M :: #{atom() => number()}             |         |
) -> #{atom() => number()}.                |         |
maps_with_1(Ks, M) ->                      | OK      |
    maps:with(Ks, M).                      |         |
                                           |         |
-spec maps_with_2(#{                       |         |
    a := atom,                             |         |
    n => number()                          |         |
}) -> #{a := atom()}.                      |         |
maps_with_2(M) ->                          | OK      |
    maps:with([a], M).                     |         |
                                           |         |
-spec maps_with_3(#{                       |         |
    a := atom,                             |         |
    n => number()                          |         |
}) -> #{n => number()}.                    |         |
maps_with_3(M) ->                          | OK      |
    maps:with([n], M).                     |         |
                                           |         |
-spec maps_with_4                          |         |
    (#{a := av, b := bv})                  |         |
    -> #{a => av, b => bv}.                |         |
maps_with_4(M) ->                          | OK      |
    L = [a, c, d],                         |         |
    maps:with(L, M).                       |         |
                                           |         |
-spec maps_with_5                          |         |
    (#{a := av, b := bv})                  |         |
    -> #{a => av, b => bv}.                |         |
maps_with_5(M) ->                          | OK      |
    maps:with([a, c, d], M).               |         |
                                           |         |
-spec lists_flatten_nil_1(                 |         |
    [[atom()]], [atom()]                   |         |
) -> [atom()].                             |         |
lists_flatten_nil_1(                       | OK      |
    L1, L2                                 |         |
) ->                                       |         |
    lists:flatten([L1, L2, []]).           |         |
                                           |         |
-spec lists_flatten_nil_2(                 |         |
    atom(), atom(), boolean()              |         |
) -> [atom()].                             |         |
lists_flatten_nil_2(                       | OK      |
    A1, A2, Flag                           |         |
) ->                                       |         |
    lists:flatten([                        |         |
        a,                                 |         |
        b,                                 |         |
        case Flag of                       |         |
            true -> A1;                    |         |
            false -> []                    |         |
        end,                               |         |
        case Flag of                       |         |
            true -> A2;                    |         |
            false -> []                    |         |
        end                                |         |
    ]).                                    |         |
                                           |         |
                                           |         |
-spec list_flatten_nil_3() -> [].          |         |
list_flatten_nil_3() ->                    | OK      |
    lists:flatten([[], [], []]).           |         |
                                           |         |
-spec filename_join_1_1_wip() ->           |         |
    file:filename().                       |         |
filename_join_1_1_wip() ->                 | ERROR   |
    filename:join(["server", "erl"]).      |         | filename:join([string_lit, string_lit]).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: file:filename()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with string()
                                           |         |
-spec filename_join_1_1_neg() ->           |         |
    file:filename().                       |         |
filename_join_1_1_neg() ->                 | ERROR   |
    filename:join(["server", <<>>]).       |         | filename:join([string_lit, <<..>>]).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: file:filename()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with string()
                                           |         |
-spec filename_join_1_2_neg() ->           |         |
    file:filename().                       |         |
filename_join_1_2_neg() ->                 | ERROR   |
    filename:join([<<>>, ""]).             |         | filename:join([<<..>>, string_lit]).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: file:filename()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with string()
                                           |         |
-spec filename_join_1_3() ->               |         |
    file:filename_all().                   |         |
filename_join_1_3() ->                     | OK      |
    filename:join([<<>>, ""]).             |         |
                                           |         |
-spec filename_join_1_4() ->               |         |
    file:filename_all().                   |         |
filename_join_1_4() ->                     | OK      |
    filename:join(["", <<>>]).             |         |
                                           |         |
-spec filename_join_1_5() ->               |         |
    binary().                              |         |
filename_join_1_5() ->                     | ERROR   |
    filename:join([<<>>, <<>>]).           |         | filename:join([<<..>>, <<..>>]).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: binary()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with binary()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with binary()
                                           |         |   because
                                           |         |   string() is not compatible with binary()
                                           |         |
-spec filename_join_1_6() ->               |         |
    file:filename_all().                   |         |
filename_join_1_6() ->                     | OK      |
    filename:join([atom, <<>>]).           |         |
                                           |         |
-spec filename_join_1_7() ->               |         |
    file:filename_all().                   |         |
filename_join_1_7() ->                     | OK      |
    filename:join([<<>>, atom]).           |         |
                                           |         |
-spec filename_join_1_8_neg() ->           |         |
    file:filename_all().                   |         |
filename_join_1_8_neg() ->                 | ERROR   |
    filename:join([<<>>, self()]).         |         | [<<..>>, erlang:self()].
                                           |         | Expression has type:   [binary() | pid()]
                                           |         | Context expected type: [file:name_all()]
                                           |         | 
                                           |         |   [binary() | pid()] is not compatible with [file:name_all()]
                                           |         |   because
                                           |         |   binary() | pid() is not compatible with file:name_all()
                                           |         |   because
                                           |         |   binary() | pid() is not compatible with string() | atom() | file:deep_list() | binary()
                                           |         |   because
                                           |         |   pid() is not compatible with string() | atom() | file:deep_list() | binary()
                                           |         |
-spec filename_join_2_1_wip() ->           |         |
    file:filename().                       |         |
filename_join_2_1_wip() ->                 | ERROR   |
    filename:join("server", "erl").        |         | filename:join(string_lit, string_lit).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: file:filename()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with string()
                                           |         |
-spec filename_join_2_1_neg() ->           |         |
    file:filename().                       |         |
filename_join_2_1_neg() ->                 | ERROR   |
    filename:join("server", <<>>).         |         | filename:join(string_lit, <<..>>).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: file:filename()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with string()
                                           |         |
-spec filename_join_2_2_neg() ->           |         |
    file:filename().                       |         |
filename_join_2_2_neg() ->                 | ERROR   |
    filename:join(<<>>, "").               |         | filename:join(<<..>>, string_lit).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: file:filename()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with file:filename()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with string()
                                           |         |
-spec filename_join_2_3() ->               |         |
    file:filename_all().                   |         |
filename_join_2_3() ->                     | OK      |
    filename:join(<<>>, "").               |         |
                                           |         |
-spec filename_join_2_4() ->               |         |
    file:filename_all().                   |         |
filename_join_2_4() ->                     | OK      |
    filename:join("", <<>>).               |         |
                                           |         |
-spec filename_join_2_6_neg() ->           |         |
    binary().                              |         |
filename_join_2_6_neg() ->                 | ERROR   |
    filename:join(atom, <<>>).             |         | filename:join('atom', <<..>>).
                                           |         | Expression has type:   file:filename_all()
                                           |         | Context expected type: binary()
                                           |         | 
                                           |         |   file:filename_all() is not compatible with binary()
                                           |         |   because
                                           |         |   string() | binary() is not compatible with binary()
                                           |         |   because
                                           |         |   string() is not compatible with binary()
                                           |         |
-spec filename_join_2_7() ->               |         |
    file:filename_all().                   |         |
filename_join_2_7() ->                     | OK      |
    filename:join(<<>>, atom).             |         |
                                           |         |
-spec filename_join_2_8_neg() ->           |         |
    file:filename_all().                   |         |
filename_join_2_8_neg() ->                 | ERROR   |
    filename:join(<<>>, self()).           |         | erlang:self().
                                           |         | Expression has type:   pid()
                                           |         | Context expected type: file:name_all()
                                           |         | 
                                           |         |   pid() is not compatible with file:name_all()
                                           |         |   because
                                           |         |   pid() is not compatible with string() | atom() | file:deep_list() | binary()
                                           |         |   because
                                           |         |   pid() is not compatible with string()
                                           |         |
-spec my_filter1(atom() | char())          |         |
        -> [char()].                       |         |
my_filter1(A) when is_atom(A) ->           | OK      |
    atom_to_list(A);                       |         |
my_filter1(C) when is_number(C) ->         |         |
    [C].                                   |         |
                                           |         |
-spec my_filter2(atom() | char())          |         |
        -> [atom() | char()].              |         |
my_filter2(A) when is_atom(A) ->           | OK      |
    atom_to_list(A);                       |         |
my_filter2(C) when is_number(C) ->         |         |
    [C].                                   |         |
                                           |         |
-spec queue_filter_20(                     |         |
    queue:queue(atom() | char())           |         |
) -> queue:queue(atom() | char()).         |         |
queue_filter_20(Q) ->                      | OK      |
    queue:filter(                          |         |
        fun my_filter1/1,                  |         |
        Q                                  |         |
    ).                                     |         |
                                           |         |
-spec queue_filter_21_neg(                 |         |
    queue:queue(atom() | char())           |         |
) -> queue:queue(char()).                  |         |
queue_filter_21_neg(Q) ->                  | ERROR   |
    queue:filter(                          |         | queue:filter(my_filter1/1, Q).
                                           |         | Expression has type:   queue:queue(atom() | number())
                                           |         | Context expected type: queue:queue(number())
                                           |         | 
                                           |         |   queue:queue(atom() | number()) is not compatible with queue:queue(number())
                                           |         |   because
                                           |         |   atom() | number() is not compatible with number()
                                           |         |   because
                                           |         |   atom() is not compatible with number()
        fun my_filter1/1,                  |         |
        Q                                  |         |
    ).                                     |         |
                                           |         |
-spec queue_filter_22(                     |         |
    queue:queue(atom() | char())           |         |
) -> queue:queue(atom() | char()).         |         |
queue_filter_22(Q) ->                      | OK      |
    queue:filter(                          |         |
        fun my_filter2/1,                  |         |
        Q                                  |         |
    ).                                     |         |
                                           |         |
-type state1() :: #{                       |         |
    module := module(),                    |         |
    count := number()                      |         |
}.                                         |         |
                                           |         |
-type state2() :: #{                       |         |
    module => module(),                    |         |
    count => number()                      |         |
}.                                         |         |
                                           |         |
-spec maps_put1() -> state1().             |         |
maps_put1() ->                             | OK      |
    M1 = #{},                              |         |
    M2 = maps:put(module, foo, M1),        |         |
    M3 = maps:put(count, 0, M2),           |         |
    M3.                                    |         |
                                           |         |
-spec maps_put2(boolean()) -> state1().    |         |
maps_put2(B) ->                            | ERROR   |
    M1 = #{},                              |         |
    M2 = maps:put(module, foo, M1),        |         |
    M3 =                                   |         |
        case B of                          |         |
            true ->                        |         |
                maps:put(count, 0, M2);    |         |
            false -> M2                    |         |
        end,                               |         |
    M3.                                    |         | M3.
                                           |         | Expression has type:   #S{count := number(), module := 'foo'} | #S{module := 'foo'}
                                           |         | Context expected type: state1()
                                           |         | 
                                           |         |   #S{count := number(), module := 'foo'} | #S{module := 'foo'} is not compatible with state1()
                                           |         |   because
                                           |         |   #S{count := number(), module := 'foo'} | #S{module := 'foo'} is not compatible with #S{count := number(), module := atom()}
                                           |         |   because
                                           |         |   #S{module := 'foo'} is not compatible with #S{count := number(), module := atom()}
                                           |         |   These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    count  := ...
                                           |         |      ...
                                           |         |   }
                                           |         |
-spec maps_put3(boolean()) -> state2().    |         |
maps_put3(B) ->                            | OK      |
    M1 = #{},                              |         |
    M2 = maps:put(module, foo, M1),        |         |
    M3 =                                   |         |
        case B of                          |         |
            true ->                        |         |
                maps:put(count, 0, M2);    |         |
            false -> M1                    |         |
        end,                               |         |
    M3.                                    |         |
                                           |         |
-type a_n_map() :: #{atom() => number()}.  |         |
                                           |         |
-spec sum_numbers1(a_n_map())              |         |
        -> number().                       |         |
sum_numbers1(M) ->                         | OK      |
    maps:fold(                             |         |
        fun (_Atom, Num, Sum) ->           |         |
            Num + Sum                      |         |
        end,                               |         |
        0,                                 |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec sum_numbers2_neg(a_n_map())          |         |
        -> number().                       |         |
sum_numbers2_neg(M) ->                     | ERROR   |
    maps:fold(                             |         |
        fun (Atom, _Num, Sum) ->           |         |
            Atom + Sum                     |         | Atom.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
        end,                               |         |
        0,                                 |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec filter_rows                          |         |
  ({Rows, FilterTs}) -> [User]             |         |
  when                                     |         |
  Rows :: [                                |         |
    {User, undefined, integer()} |         |         |
    User                                   |         |
  ],                                       |         |
  FilterTs :: integer() | undefined,       |         |
  User :: binary().                        |         |
filter_rows({Rows, FTS}) ->                | OK      |
  lists:filtermap(fun                      |         |
    ({_, _, Ts})                           |         |
        when FTS =/= undefined,            |         |
             FTS > Ts ->                   |         |
      false;                               |         |
    ({User, _, _}) ->                      |         |
      {true, User};                        |         |
    (User) ->                              |         |
      {true, User}                         |         |
    end, Rows).                            |         |
                                           |         |
-spec file_open1() -> pid().               |         |
file_open1() ->                            | OK      |
    {ok, Device} =                         |         |
        file:open("/file", [read]),        |         |
    Device.                                |         |
                                           |         |
-spec file_open2() -> file:fd().           |         |
file_open2() ->                            | OK      |
    {ok, Device} =                         |         |
        file:open("/file", [read, raw]),   |         |
    Device.                                |         |
                                           |         |
-spec file_open3_neg                       |         |
    ([file:mode()]) -> file:fd().          |         |
file_open3_neg(Modes) ->                   | ERROR   |
    {ok, Device} =                         |         |
        file:open("/file", Modes),         |         |
    Device.                                |         | Device.
                                           |         | Expression has type:   file:io_device()
                                           |         | Context expected type: file:fd()
                                           |         | 
                                           |         |   file:io_device() is not compatible with file:fd()
                                           |         |   because
                                           |         |   pid() | file:fd() is not compatible with file:fd()
                                           |         |   because
                                           |         |   pid() | file:fd() is not compatible with #file_descriptor{}
                                           |         |   because
                                           |         |   pid() is not compatible with #file_descriptor{}
                                           |         |
-spec file_open5_neg                       |         |
    (file:mode()) -> file:fd().            |         |
file_open5_neg(Mode) ->                    | ERROR   |
    {ok, Device} =                         |         |
        file:open("/file", [Mode]),        |         |
    Device.                                |         | Device.
                                           |         | Expression has type:   file:io_device()
                                           |         | Context expected type: file:fd()
                                           |         | 
                                           |         |   file:io_device() is not compatible with file:fd()
                                           |         |   because
                                           |         |   pid() | file:fd() is not compatible with file:fd()
                                           |         |   because
                                           |         |   pid() | file:fd() is not compatible with #file_descriptor{}
                                           |         |   because
                                           |         |   pid() is not compatible with #file_descriptor{}
                                           |         |
-spec maps_remove1(                        |         |
    #{a := integer()}                      |         |
) -> #{}.                                  |         |
maps_remove1(M) ->                         | OK      |
    maps:remove(a, M).                     |         |
                                           |         |
-spec maps_remove2(                        |         |
    #{a := integer()}                      |         |
) -> #{a := integer()}.                    |         |
maps_remove2(M) ->                         | OK      |
    maps:remove(b, M).                     |         |
                                           |         |
-spec maps_remove3_neg(                    |         |
    atom(),                                |         |
    #{a := integer()}                      |         |
) -> #{a := integer()}.                    |         |
maps_remove3_neg(A, M) ->                  | ERROR   |
    maps:remove(A, M).                     |         | maps:remove(A, M).
                                           |         | Expression has type:   dict  map #D{atom() => number()}
                                           |         | Context expected type: shape map #S{a := number()}
                                           |         |
-spec maps_remove4(                        |         |
    #{a := integer(), b := atom()} |       |         |
    #{a := atom(), b := pid()}             |         |
) -> #{b := atom()} | #{b => pid()}.       |         |
maps_remove4(M) ->                         | OK      |
    maps:remove(a, M).                     |         |
                                           |         |
-spec maps_remove5(                        |         |
    #{atom() => binary()}                  |         |
) -> #{atom() => binary()}.                |         |
maps_remove5(M) ->                         | OK      |
    maps:remove(a, M).                     |         |
                                           |         |
-spec maps_filtermap_1(                    |         |
    #{atom() => atom()}                    |         |
) -> #{atom() => binary()}.                |         |
maps_filtermap_1(M) ->                     | OK      |
    maps:filtermap(                        |         |
        fun (_, V) ->                      |         |
            {true, atom_to_binary(V)}      |         |
        end,                               |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filtermap_2(                    |         |
    #{a := atom(), b => atom()}            |         |
) -> #{a => binary(), b => binary()}.      |         |
maps_filtermap_2(M) ->                     | OK      |
    maps:filtermap(                        |         |
        fun (_, V) ->                      |         |
            {true, atom_to_binary(V)}      |         |
        end,                               |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filtermap_3_neg(                |         |
    #{a := atom(), b := atom(), c := atom(……         |
) -> #{a := atom(), b := binary()}.        |         |
maps_filtermap_3_neg(M) ->                 | ERROR   |
    maps:filtermap(                        |         | maps:filtermap(fun, M).
                                           |         | Expression has type:   #S{a => atom() | binary(), b => atom() | binary(), c => atom() | binary()}
                                           |         | Context expected type: #S{a := atom(), b := binary()}
                                           |         | 
                                           |         | These associations do not match:
                                           |         | 
                                           |         |   #S{
                                           |         | -    a := ...
                                           |         | +    a => ...
                                           |         | -    b := ...
                                           |         | +    b => ...
                                           |         | +    c => ...
                                           |         |   }
        fun                                |         |
            (a, V) -> true;                |         |
            (b, V) -> {true, atom_to_binar……         |
            (c, _) -> false                |         |
        end,                               |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filtermap_4(                    |         |
    #{atom() => atom()}                    |         |
) -> #{atom() => none()}.                  |         |
maps_filtermap_4(M) ->                     | OK      |
    maps:filtermap(                        |         |
        fun (_, V) -> false end,           |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filtermap_5_neg(                |         |
    #{atom() => atom()}                    |         |
) -> #{atom() => atom()}.                  |         |
maps_filtermap_5_neg(M) ->                 | ERROR   |
    maps:filtermap(                        |         | maps:filtermap(fun, M).
                                           |         | Expression has type:   #D{atom() => binary()}
                                           |         | Context expected type: #D{atom() => atom()}
                                           |         | 
                                           |         |   #D{atom() => binary()} is not compatible with #D{atom() => atom()}
                                           |         |   because
                                           |         |   binary() is not compatible with atom()
        fun (_, V) ->                      |         |
            {true, atom_to_binary(V)}      |         |
        end,                               |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filtermap_6_neg(                |         |
    #{atom() => atom()}                    |         |
) -> #{atom() => binary()}.                |         |
maps_filtermap_6_neg(M) ->                 | ERROR   |
    maps:filtermap(                        |         |
        fun (_, _) -> err end,             |         | 'err'.
                                           |         | Expression has type:   'err'
                                           |         | Context expected type: boolean() | {'true', term()}
                                           |         | 
                                           |         |   'err' is not compatible with boolean() | {'true', term()}
                                           |         |   because
                                           |         |   'err' is not compatible with boolean()
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec maps_filtermap_7_neg(                |         |
    #{atom() => binary()}                  |         |
) -> #{atom() => atom()}.                  |         |
maps_filtermap_7_neg(M) ->                 | ERROR   |
    maps:filtermap(                        |         |
        fun (_, V) -> {true, atom_to_binar……         | V.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: atom()
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec re_replace_1(iodata()) -> string().  |         |
re_replace_1(Subj) ->                      | OK      |
    re:replace(Subj, "+", "-", [{return, l……         |
                                           |         |
-spec re_replace_2(iodata()) -> binary().  |         |
re_replace_2(Subj) ->                      | OK      |
    re:replace(Subj, "+", "-", [{return, b……         |
                                           |         |
-spec re_replace_3_neg(iodata()) -> string……         |
re_replace_3_neg(Subj) ->                  | ERROR   |
    re:replace(Subj, "+", "-", [{return, b……         | re:replace(Subj, string_lit, string_lit, [{'return', 'binary'}]).
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: string()
                                           |         |
-spec re_replace_4_neg(iodata()) -> binary……         |
re_replace_4_neg(Subj) ->                  | ERROR   |
    re:replace(Subj, "+", "-", [{return, l……         | re:replace(Subj, string_lit, string_lit, [{'return', 'list'}]).
                                           |         | Expression has type:   string()
                                           |         | Context expected type: binary()
                                           |         |
-spec re_replace_5_neg(atom()) -> binary()……         |
re_replace_5_neg(Subj) ->                  | ERROR   |
    Res = re:replace(Subj, "+", "-", [{ret……         | Subj.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: iodata() | unicode:charlist()
                                           |         | 
                                           |         |   atom() is not compatible with iodata() | unicode:charlist()
                                           |         |   because
                                           |         |   atom() is not compatible with iodata()
    Res.                                   |         |
                                           |         |
-spec re_replace_6_neg(iodata()) -> term()……         |
re_replace_6_neg(Subj) ->                  | ERROR   |
    Res = re:replace(Subj, "+", "-", [{ret……         | [{'return', 'something'}].
                                           |         | Expression has type:   [{'return', 'something'}]
                                           |         | Context expected type: [{'newline', 'cr' | 'lf' | 'any' | 'crlf' | 'anycrlf'} | 'notempty_atstart' | 'noteol' | 'bsr_unicode' | 'notbol' | 'global' | {'match_limit_recursion', number()} | 'bsr_anycrlf' | re:compile_option() | {'match_limit', number()} | {'offset', number()} | 'notempty' | {'return', 'iodata' | 'list' | 'binary'} | 'anchored']
                                           |         | 
                                           |         |   [{'return', 'something'}] is not compatible with [{'newline', 'cr' | 'lf' | 'any' | 'crlf' | 'anycrlf'} | 'notempty_atstart' | 'noteol' | 'bsr_unicode' | 'notbol' | 'global' | {'match_limit_recursion', number()} | 'bsr_anycrlf' | re:compile_option() | {'match_limit', number()} | {'offset', number()} | 'notempty' | {'return', 'iodata' | 'list' | 'binary'} | 'anchored']
                                           |         |   because
                                           |         |   {'return', 'something'} is not compatible with {'newline', 'cr' | 'lf' | 'any' | 'crlf' | 'anycrlf'} | 'notempty_atstart' | 'noteol' | 'bsr_unicode' | 'notbol' | 'global' | {'match_limit_recursion', number()} | 'bsr_anycrlf' | re:compile_option() | {'match_limit', number()} | {'offset', number()} | 'notempty' | {'return', 'iodata' | 'list' | 'binary'} | 'anchored'
                                           |         |   because
                                           |         |   at tuple index 2:
                                           |         |   {'return', 'something'} is not compatible with {'return', 'iodata' | 'list' | 'binary'}
                                           |         |   because
                                           |         |   'something' is not compatible with 'iodata' | 'list' | 'binary'
    Res.                                   |         |
                                           |         |
-spec maps_fold_keys(#{a => atom(), b => a……         |
maps_fold_keys(M) ->                       | ERROR   |
    maps:fold(                             |         |
        fun(K, _V, Acc) -> process_key(K),……         | K.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: 'a' | 'b'
                                           |         | 
                                           |         |   atom() is not compatible with 'a' | 'b'
                                           |         |   because
                                           |         |   atom() is not compatible with 'a'
        ok,                                |         |
        M                                  |         |
    ).                                     |         |
                                           |         |
-spec process_key(a | b) -> ok.            |         |
process_key(_K) -> ok.                     | OK      |
